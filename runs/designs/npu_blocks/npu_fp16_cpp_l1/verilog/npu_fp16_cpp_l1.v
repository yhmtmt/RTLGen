/* Generated by Yosys 0.55+46 (git sha1 aa1daa702, clang++ 18.1.8 -fPIC -O3) */

module gemm_mac_fp16_ieee(A, B, C, negateAB, negateC, RndMode, R);
  wire _000_;
  wire _001_;
  wire _002_;
  wire _003_;
  wire _004_;
  wire _005_;
  wire _006_;
  wire _007_;
  wire _008_;
  wire _009_;
  wire _010_;
  wire _011_;
  wire _012_;
  wire [4:0] _013_;
  wire _014_;
  wire _015_;
  wire _016_;
  wire _017_;
  wire [6:0] _018_;
  wire [6:0] _019_;
  wire [6:0] _020_;
  wire [6:0] _021_;
  wire [6:0] _022_;
  wire _023_;
  wire [6:0] _024_;
  wire [6:0] _025_;
  wire [6:0] _026_;
  wire [5:0] _027_;
  wire [5:0] _028_;
  wire [5:0] _029_;
  wire [47:0] _030_;
  wire _031_;
  wire _032_;
  wire _033_;
  wire _034_;
  wire _035_;
  wire _036_;
  wire _037_;
  wire _038_;
  wire _039_;
  wire _040_;
  wire _041_;
  wire [21:0] _042_;
  wire _043_;
  wire [37:0] _044_;
  wire _045_;
  wire [36:0] _046_;
  wire [37:0] _047_;
  wire [37:0] _048_;
  wire [37:0] _049_;
  wire _050_;
  wire _051_;
  wire _052_;
  wire _053_;
  wire _054_;
  wire [36:0] _055_;
  wire _056_;
  wire [4:0] _057_;
  wire [6:0] _058_;
  wire [6:0] _059_;
  wire _060_;
  wire _061_;
  wire _062_;
  wire _063_;
  wire _064_;
  wire _065_;
  wire _066_;
  wire _067_;
  wire _068_;
  wire _069_;
  wire _070_;
  wire _071_;
  wire _072_;
  wire _073_;
  wire [5:0] _074_;
  wire [5:0] _075_;
  wire _076_;
  wire _077_;
  wire _078_;
  wire [5:0] _079_;
  wire _080_;
  wire [5:0] _081_;
  wire [72:0] _082_;
  wire [6:0] _083_;
  wire [6:0] _084_;
  wire [6:0] _085_;
  wire [6:0] _086_;
  wire _087_;
  wire _088_;
  wire _089_;
  wire [6:0] _090_;
  wire [6:0] _091_;
  wire _092_;
  wire _093_;
  wire _094_;
  wire _095_;
  wire _096_;
  wire _097_;
  wire _098_;
  wire _099_;
  wire _100_;
  wire _101_;
  wire _102_;
  wire _103_;
  wire _104_;
  wire _105_;
  wire _106_;
  wire _107_;
  wire _108_;
  wire _109_;
  wire _110_;
  wire _111_;
  wire _112_;
  wire _113_;
  wire _114_;
  wire _115_;
  wire _116_;
  wire _117_;
  wire [1:0] _118_;
  wire _119_;
  wire [9:0] _120_;
  wire _121_;
  wire [9:0] _122_;
  wire _123_;
  wire _124_;
  wire _125_;
  wire _126_;
  wire _127_;
  wire _128_;
  wire _129_;
  wire _130_;
  wire _131_;
  wire _132_;
  wire _133_;
  wire _134_;
  wire _135_;
  wire _136_;
  wire _137_;
  wire _138_;
  wire _139_;
  wire _140_;
  wire [6:0] _141_;
  wire _142_;
  wire [6:0] _143_;
  wire _144_;
  wire _145_;
  wire [6:0] _146_;
  wire [6:0] _147_;
  wire [16:0] _148_;
  wire _149_;
  wire _150_;
  wire _151_;
  wire _152_;
  wire _153_;
  wire _154_;
  wire _155_;
  wire _156_;
  wire _157_;
  wire _158_;
  wire [15:0] _159_;
  wire [15:0] _160_;
  wire _161_;
  wire _162_;
  wire _163_;
  wire _164_;
  wire _165_;
  wire _166_;
  wire _167_;
  wire _168_;
  wire _169_;
  wire _170_;
  wire _171_;
  wire _172_;
  wire _173_;
  wire _174_;
  wire _175_;
  wire _176_;
  wire _177_;
  wire _178_;
  wire _179_;
  wire _180_;
  wire _181_;
  wire _182_;
  wire _183_;
  wire _184_;
  wire [4:0] _185_;
  wire [4:0] _186_;
  wire [5:0] _187_;
  wire _188_;
  wire _189_;
  wire _190_;
  wire _191_;
  wire _192_;
  wire _193_;
  wire _194_;
  wire _195_;
  wire _196_;
  wire _197_;
  wire _198_;
  wire _199_;
  wire _200_;
  wire _201_;
  wire _202_;
  wire _203_;
  wire _204_;
  wire _205_;
  wire _206_;
  wire _207_;
  wire _208_;
  wire _209_;
  wire _210_;
  wire _211_;
  wire _212_;
  wire _213_;
  wire _214_;
  wire _215_;
  wire _216_;
  wire _217_;
  wire _218_;
  wire _219_;
  wire _220_;
  wire _221_;
  wire _222_;
  wire _223_;
  wire _224_;
  wire _225_;
  wire _226_;
  wire _227_;
  wire _228_;
  wire _229_;
  wire _230_;
  wire _231_;
  wire _232_;
  wire _233_;
  wire _234_;
  wire _235_;
  wire _236_;
  wire _237_;
  wire _238_;
  wire _239_;
  wire _240_;
  wire _241_;
  wire _242_;
  input [15:0] A;
  wire [15:0] A;
  input [15:0] B;
  wire [15:0] B;
  input [15:0] C;
  wire [15:0] C;
  output [15:0] R;
  wire [15:0] R;
  input [1:0] RndMode;
  wire [1:0] RndMode;
  wire [4:0] aexp;
  wire [4:0] aexpfield;
  wire [5:0] aexpplusbexp;
  wire ahasnonnullsig;
  wire aisinf;
  wire aisinfornan;
  wire aisnan;
  wire aisnormal;
  wire aiszero;
  wire asgn;
  wire [10:0] asig;
  wire [9:0] asigfield;
  wire [4:0] bexp;
  wire [4:0] bexpfield;
  wire bhasnonnullsig;
  wire [37:0] bigsum;
  wire [37:0] bigsum2;
  wire [36:0] bigsumabs;
  wire [25:0] bigsumabslowerbits;
  wire [72:0] bigsumnormd;
  wire bisinf;
  wire bisinfornan;
  wire bisnan;
  wire bisnormal;
  wire biszero;
  wire bsgn;
  wire [10:0] bsig;
  wire [9:0] bsigfield;
  wire [4:0] cexp;
  wire [4:0] cexpfield;
  wire chasnonnullsig;
  wire cisinf;
  wire cisinfornan;
  wire cisnan;
  wire cisnormal;
  wire ciszero;
  wire csgn;
  wire [10:0] csig;
  wire [9:0] csigfield;
  wire [37:0] csiginverted;
  wire [47:0] csigshifted;
  wire [36:0] csigshiftedt;
  wire effectivesub;
  wire [6:0] expdiff;
  wire expdiffnotlarge;
  wire [6:0] expdiffprepare;
  wire expdiffsmall;
  wire expdiffverysmall;
  wire [6:0] exponentresult1;
  wire [6:0] exptentative;
  wire [6:0] expupdate;
  wire finalrisinf;
  wire [1:0] fracleadingbits;
  wire [1:0] fracleadingbitsnormal;
  wire [9:0] fracresultnormd;
  wire fracresultroundbit;
  wire fracresultstickybit;
  wire [13:0] fractentative;
  wire [4:0] \ieeefpfma_5_10_comb_uid2leadingzerocounter:287 ;
  wire [14:0] inf;
  wire [4:0] l;
  wire [14:0] nan;
  input negateAB;
  wire negateAB;
  input negateC;
  wire negateC;
  wire [72:0] \normalizationshifter:325 ;
  wire [5:0] normshiftvalue;
  wire [21:0] p;
  wire [36:0] paligned;
  wire [16:0] resultbeforeround;
  wire [16:0] resultrounded;
  wire [47:0] \rightshiftercomponent:228 ;
  wire risnan;
  wire rissubnormal;
  wire riszero;
  wire round;
  wire roverflowed;
  wire rsgn;
  wire rsgntentative;
  wire [5:0] shiftvalue;
  wire [5:0] shiftvaluecasesubnormal;
  wire sticky1;
  wire sticky2;
  wire tentativerisinf;
  wire [6:0] tmpexpcomp1;
  wire [6:0] tmpexpcomp2;
  wire [6:0] tmpexpcomp3;
  wire [6:0] tmpexpcompres1;
  wire [6:0] tmpexpcompres2;
  assign _166_ = _111_ | A[13];
  assign _187_ = { aexp[4], aexp } + { bexp[4], bexp };
  assign _189_ = C[10] | C[11];
  assign _190_ = _189_ | C[12];
  assign _191_ = _190_ | C[13];
  assign _192_ = _191_ | C[14];
  assign _177_ = _166_ | A[14];
  assign _193_ = C[10] & C[11];
  assign _194_ = _193_ & C[12];
  assign _195_ = _194_ & C[13];
  assign _196_ = _195_ & C[14];
  assign _197_ = C[0] | C[1];
  assign _198_ = _197_ | C[2];
  assign _200_ = _198_ | C[3];
  assign _201_ = _200_ | C[4];
  assign _202_ = _201_ | C[5];
  assign _203_ = _202_ | C[6];
  assign _204_ = _203_ | C[7];
  assign _205_ = _204_ | C[8];
  assign _206_ = _205_ | C[9];
  assign _207_ = ~ cisnormal;
  assign _208_ = ~ chasnonnullsig;
  assign _209_ = _207_ & _208_;
  assign _211_ = ~ chasnonnullsig;
  assign _188_ = A[10] & A[11];
  assign _212_ = cisinfornan & _211_;
  assign _213_ = cisinfornan & chasnonnullsig;
  assign _214_ = aisnan | bisnan;
  assign _215_ = _214_ | cisnan;
  assign _216_ = aisinf | bisinf;
  assign _217_ = _216_ & cisinf;
  assign _218_ = asgn ^ bsgn;
  assign _219_ = _218_ ^ csgn;
  assign _220_ = _217_ & _219_;
  assign _222_ = _215_ | _220_;
  assign _223_ = biszero | bisnan;
  assign _224_ = ~ _223_;
  assign _225_ = aisinf & _224_;
  assign _226_ = aiszero | aisnan;
  assign _227_ = ~ _226_;
  assign _228_ = bisinf & _227_;
  assign _229_ = _225_ | _228_;
  assign _230_ = ~ cisnan;
  assign _231_ = _229_ & _230_;
  assign _233_ = asgn ^ bsgn;
  assign _199_ = _188_ & A[12];
  assign _234_ = _233_ ^ csgn;
  assign _235_ = ~ _234_;
  assign _236_ = cisinf & _235_;
  assign _237_ = ~ cisinf;
  assign _238_ = _236_ | _237_;
  assign _239_ = _231_ & _238_;
  assign _240_ = aisnan | bisnan;
  assign _241_ = ~ _240_;
  assign _242_ = cisinf & _241_;
  assign _002_ = aisinf | bisinf;
  assign _003_ = asgn ^ bsgn;
  assign _004_ = _003_ ^ csgn;
  assign _005_ = ~ _004_;
  assign _006_ = _002_ & _005_;
  assign _007_ = aisinf | bisinf;
  assign _008_ = ~ _007_;
  assign _009_ = _006_ | _008_;
  assign _010_ = _242_ & _009_;
  assign _011_ = _239_ | _010_;
  assign _210_ = _199_ & A[13];
  assign _013_ = cexpfield - { 4'h7, cisnormal };
  assign _014_ = negateAB ^ asgn;
  assign _015_ = _014_ ^ bsgn;
  assign _016_ = negateC ^ csgn;
  assign _017_ = _015_ ^ _016_;
  assign _018_ = { 2'h0, aexpfield } + { 2'h0, bexpfield };
  assign _019_ = _018_ - { 6'h07, aisnormal };
  assign _020_ = _019_ - { 6'h00, bisnormal };
  assign _021_ = { 2'h0, cexpfield } - expdiffprepare;
  assign _221_ = _210_ & A[14];
  assign _022_ = _021_ - { 6'h00, cisnormal };
  assign _024_ = expdiff + 7'h16;
  assign _025_ = expdiff - 7'h03;
  assign _026_ = expdiff - 7'h0e;
  assign _027_ = expdiffverysmall ? 6'h25 : _029_;
  assign _028_ = 6'h0e - expdiff[5:0];
  assign _029_ = expdiffnotlarge ? _028_ : 6'h00;
  assign _031_ = csigshifted[0] | csigshifted[1];
  assign _032_ = _031_ | csigshifted[2];
  assign _033_ = _032_ | csigshifted[3];
  assign _035_ = _033_ | csigshifted[4];
  assign _232_ = A[0] | A[1];
  assign _036_ = _035_ | csigshifted[5];
  assign _037_ = _036_ | csigshifted[6];
  assign _038_ = _037_ | csigshifted[7];
  assign _039_ = _038_ | csigshifted[8];
  assign _040_ = _039_ | csigshifted[9];
  assign _041_ = _040_ | csigshifted[10];
  assign _042_ = { 11'h000, asig } * { 11'h000, bsig };
  assign _001_ = _232_ | A[2];
  assign _043_ = ~ effectivesub;
  assign _044_ = _043_ ? { 1'h0, csigshiftedt } : { 1'h1, _046_ };
  assign _046_ = ~ csigshiftedt;
  assign _047_ = csiginverted + { 1'h0, paligned };
  assign _048_ = _047_ + { 37'h0000000000, effectivesub };
  assign _049_ = { 1'h0, csigshiftedt } - { 1'h0, paligned };
  assign _050_ = asgn ^ bsgn;
  assign _051_ = _050_ ^ negateAB;
  assign _052_ = _051_ ^ bigsum[37];
  assign _012_ = _001_ | A[3];
  assign _053_ = ~ effectivesub;
  assign _054_ = bigsum2[37] | _053_;
  assign _055_ = _054_ ? bigsum[36:0] : bigsum2[36:0];
  assign _058_ = { aexpplusbexp[5], aexpplusbexp } + 7'h11;
  assign _059_ = tmpexpcompres1 - { 2'h0, l };
  assign _060_ = ~ cisnormal;
  assign _061_ = expdiffsmall | _060_;
  assign _023_ = _012_ | A[4];
  assign _062_ = _061_ & tmpexpcompres2[6];
  assign _063_ = l == 5'h1a;
  assign _064_ = _063_ ? expdiffsmall : 1'h0;
  assign _065_ = asgn ^ bsgn;
  assign _066_ = _065_ ^ negateAB;
  assign _068_ = csgn ^ negateC;
  assign _069_ = _066_ & _068_;
  assign _070_ = aiszero | biszero;
  assign _071_ = _070_ & ciszero;
  assign _072_ = _071_ ? _069_ : _073_;
  assign _073_ = riszero ? 1'h0 : rsgntentative;
  assign _074_ = aexpplusbexp + 6'h1c;
  assign _075_ = { 1'h0, l } + 6'h0c;
  assign _034_ = _023_ | A[5];
  assign _076_ = ~ rissubnormal;
  assign _077_ = expdiffsmall & _076_;
  assign _079_ = _077_ ? _075_ : _081_;
  assign _080_ = expdiffsmall & rissubnormal;
  assign _081_ = _080_ ? shiftvaluecasesubnormal : shiftvalue;
  assign _083_ = riszero ? 7'h73 : _084_;
  assign _084_ = rissubnormal ? 7'h72 : _090_;
  assign _085_ = { aexpplusbexp[5], aexpplusbexp } - { 2'h0, l };
  assign _086_ = _085_ + 7'h03;
  assign _087_ = ~ rissubnormal;
  assign _045_ = _034_ | A[6];
  assign _088_ = expdiffsmall & _087_;
  assign _090_ = _088_ ? _086_ : _091_;
  assign _091_ = { cexp[4], cexp[4], cexp } + 7'h01;
  assign _092_ = bigsumnormd[0] | bigsumnormd[1];
  assign _093_ = _092_ | bigsumnormd[2];
  assign _094_ = _093_ | bigsumnormd[3];
  assign _095_ = _094_ | bigsumnormd[4];
  assign _096_ = _095_ | bigsumnormd[5];
  assign _056_ = _045_ | A[7];
  assign _097_ = _096_ | bigsumnormd[6];
  assign _098_ = _097_ | bigsumnormd[7];
  assign _099_ = _098_ | bigsumnormd[8];
  assign _101_ = _099_ | bigsumnormd[9];
  assign _102_ = _101_ | bigsumnormd[10];
  assign _103_ = _102_ | bigsumnormd[11];
  assign _104_ = _103_ | bigsumnormd[12];
  assign _105_ = _104_ | bigsumnormd[13];
  assign _106_ = _105_ | bigsumnormd[14];
  assign _107_ = _106_ | bigsumnormd[15];
  assign _067_ = _056_ | A[8];
  assign _108_ = _107_ | bigsumnormd[16];
  assign _109_ = _108_ | bigsumnormd[17];
  assign _110_ = _109_ | bigsumnormd[18];
  assign _113_ = _110_ | bigsumnormd[19];
  assign _114_ = _113_ | bigsumnormd[20];
  assign _115_ = _114_ | bigsumnormd[21];
  assign _116_ = _115_ | bigsumnormd[22];
  assign _117_ = _116_ | bigsumnormd[23];
  assign _118_ = rissubnormal ? 2'h1 : fracleadingbitsnormal;
  assign _078_ = _067_ | A[9];
  assign _119_ = fracleadingbits == 2'h0;
  assign _120_ = _119_ ? fractentative[10:1] : _122_;
  assign _121_ = fracleadingbits == 2'h1;
  assign _122_ = _121_ ? fractentative[11:2] : fractentative[12:3];
  assign _089_ = ~ aisnormal;
  assign _124_ = fracleadingbits == 2'h0;
  assign _125_ = _124_ ? fractentative[0] : _127_;
  assign _126_ = fracleadingbits == 2'h1;
  assign _127_ = _126_ ? fractentative[1] : fractentative[2];
  assign _128_ = sticky1 | sticky2;
  assign _129_ = fracleadingbits == 2'h0;
  assign _100_ = ~ ahasnonnullsig;
  assign _130_ = _129_ ? _128_ : _135_;
  assign _131_ = fractentative[0] | sticky1;
  assign _132_ = _131_ | sticky2;
  assign _133_ = fracleadingbits == 2'h1;
  assign _135_ = _133_ ? _132_ : _138_;
  assign _136_ = fractentative[1] | fractentative[0];
  assign _112_ = _089_ & _100_;
  assign _137_ = _136_ | sticky1;
  assign _138_ = _137_ | sticky2;
  assign _139_ = fracresultstickybit | fracresultnormd[0];
  assign _140_ = fracresultroundbit & _139_;
  assign _141_ = riszero ? 7'h0d : _143_;
  assign _142_ = fracleadingbits == 2'h0;
  assign _123_ = ~ ahasnonnullsig;
  assign _143_ = _142_ ? 7'h0d : _146_;
  assign _144_ = fracleadingbits == 2'h1;
  assign _146_ = _144_ ? 7'h0e : 7'h0f;
  assign _147_ = exptentative + expupdate;
  assign _134_ = aisinfornan & _123_;
  assign _148_ = resultbeforeround + { 16'h0000, round };
  assign _149_ = resultrounded[16] | resultrounded[15];
  assign _150_ = resultrounded[14] & resultrounded[13];
  assign _151_ = _150_ & resultrounded[12];
  assign _145_ = aisinfornan & ahasnonnullsig;
  assign _152_ = _151_ & resultrounded[11];
  assign _153_ = _152_ & resultrounded[10];
  assign _154_ = _149_ | _153_;
  assign _155_ = tentativerisinf | roverflowed;
  assign _157_ = ~ risnan;
  assign _158_ = _157_ & finalrisinf;
  assign _159_ = _158_ ? { rsgn, inf } : _160_;
  assign _160_ = risnan ? { 1'h0, nan } : { rsgn, resultrounded[14:0] };
  assign _156_ = B[10] | B[11];
  assign _161_ = _156_ | B[12];
  assign _162_ = _161_ | B[13];
  assign _163_ = _162_ | B[14];
  assign _000_ = A[10] | A[11];
  assign _164_ = B[10] & B[11];
  assign _165_ = _164_ & B[12];
  assign _167_ = _165_ & B[13];
  assign _168_ = _167_ & B[14];
  assign _169_ = B[0] | B[1];
  assign _170_ = _169_ | B[2];
  assign _171_ = _170_ | B[3];
  assign _172_ = _171_ | B[4];
  assign _173_ = _172_ | B[5];
  assign _111_ = _000_ | A[12];
  assign _174_ = _173_ | B[6];
  assign _175_ = _174_ | B[7];
  assign _176_ = _175_ | B[8];
  assign _178_ = _176_ | B[9];
  assign _179_ = ~ bisnormal;
  assign _180_ = ~ bhasnonnullsig;
  assign _181_ = _179_ & _180_;
  assign _182_ = ~ bhasnonnullsig;
  assign _183_ = bisinfornan & _182_;
  assign _184_ = bisinfornan & bhasnonnullsig;
  assign _185_ = aexpfield - { 4'h7, aisnormal };
  assign _186_ = bexpfield - { 4'h7, bisnormal };
  lzc_26_comb_uid6 ieeefpfma_5_10_comb_uid2leadingzerocounter (
    .i(bigsumabslowerbits),
    .o(_057_)
  );
  leftshifter37_by_max_36_comb_uid8 normalizationshifter (
    .r(_082_),
    .s(normshiftvalue),
    .x(bigsumabs)
  );
  rightshifter11_by_max_37_comb_uid4 rightshiftercomponent (
    .r(_030_),
    .s(shiftvalue),
    .x(csig)
  );
  assign asgn = A[15];
  assign aexpfield = A[14:10];
  assign asigfield = A[9:0];
  assign aisnormal = _177_;
  assign aisinfornan = _221_;
  assign ahasnonnullsig = _078_;
  assign aiszero = _112_;
  assign aisinf = _134_;
  assign aisnan = _145_;
  assign bsgn = B[15];
  assign bexpfield = B[14:10];
  assign bsigfield = B[9:0];
  assign bisnormal = _163_;
  assign bisinfornan = _168_;
  assign bhasnonnullsig = _178_;
  assign biszero = _181_;
  assign bisinf = _183_;
  assign bisnan = _184_;
  assign aexp = _185_;
  assign bexp = _186_;
  assign asig = { aisnormal, asigfield };
  assign bsig = { bisnormal, bsigfield };
  assign aexpplusbexp = _187_;
  assign csgn = C[15];
  assign cexpfield = C[14:10];
  assign csigfield = C[9:0];
  assign cisnormal = _192_;
  assign cisinfornan = _196_;
  assign chasnonnullsig = _206_;
  assign ciszero = _209_;
  assign cisinf = _212_;
  assign cisnan = _213_;
  assign risnan = _222_;
  assign tentativerisinf = _011_;
  assign cexp = _013_;
  assign effectivesub = _017_;
  assign csig = { cisnormal, csigfield };
  assign expdiffprepare = _020_;
  assign expdiff = _022_;
  assign tmpexpcomp1 = _024_;
  assign expdiffverysmall = tmpexpcomp1[6];
  assign tmpexpcomp2 = _025_;
  assign expdiffsmall = tmpexpcomp2[6];
  assign tmpexpcomp3 = _026_;
  assign expdiffnotlarge = tmpexpcomp3[6];
  assign shiftvalue = _027_;
  assign csigshifted = \rightshiftercomponent:228 ;
  assign sticky1 = _041_;
  assign csigshiftedt = csigshifted[47:11];
  assign p = _042_;
  assign paligned = { 13'h0000, p, 2'h0 };
  assign csiginverted = _044_;
  assign bigsum = _048_;
  assign bigsum2 = _049_;
  assign rsgntentative = _052_;
  assign bigsumabs = _055_;
  assign bigsumabslowerbits = bigsumabs[25:0];
  assign l = \ieeefpfma_5_10_comb_uid2leadingzerocounter:287 ;
  assign tmpexpcompres1 = _058_;
  assign tmpexpcompres2 = _059_;
  assign rissubnormal = _062_;
  assign riszero = _064_;
  assign rsgn = _072_;
  assign shiftvaluecasesubnormal = _074_;
  assign normshiftvalue = _079_;
  assign bigsumnormd = \normalizationshifter:325 ;
  assign exptentative = _083_;
  assign sticky2 = _117_;
  assign fractentative = bigsumnormd[37:24];
  assign fracleadingbitsnormal = fractentative[13:12];
  assign fracleadingbits = _118_;
  assign fracresultnormd = _120_;
  assign fracresultroundbit = _125_;
  assign fracresultstickybit = _130_;
  assign round = _140_;
  assign expupdate = _141_;
  assign exponentresult1 = _147_;
  assign resultbeforeround = { exponentresult1, fracresultnormd };
  assign resultrounded = _148_;
  assign roverflowed = _154_;
  assign finalrisinf = _155_;
  assign inf = 15'h7c00;
  assign nan = 15'h7fff;
  assign \rightshiftercomponent:228  = _030_;
  assign \ieeefpfma_5_10_comb_uid2leadingzerocounter:287  = _057_;
  assign \normalizationshifter:325  = _082_;
  assign R = _159_;
endmodule

module leftshifter37_by_max_36_comb_uid8(x, s, r);
  wire [37:0] _0_;
  wire [39:0] _1_;
  wire [43:0] _2_;
  wire [51:0] _3_;
  wire [67:0] _4_;
  wire [99:0] _5_;
  wire [36:0] level0;
  wire [37:0] level1;
  wire [39:0] level2;
  wire [43:0] level3;
  wire [51:0] level4;
  wire [67:0] level5;
  wire [99:0] level6;
  wire [5:0] ps;
  output [72:0] r;
  wire [72:0] r;
  input [5:0] s;
  wire [5:0] s;
  input [36:0] x;
  wire [36:0] x;
  assign _0_ = ps[0] ? { level0, 1'h0 } : { 1'h0, level0 };
  assign _1_ = ps[1] ? { level1, 2'h0 } : { 2'h0, level1 };
  assign _2_ = ps[2] ? { level2, 4'h0 } : { 4'h0, level2 };
  assign _3_ = ps[3] ? { level3, 8'h00 } : { 8'h00, level3 };
  assign _4_ = ps[4] ? { level4, 16'h0000 } : { 16'h0000, level4 };
  assign _5_ = ps[5] ? { level5, 32'h00000000 } : { 32'h00000000, level5 };
  assign ps = s;
  assign level0 = x;
  assign level1 = _0_;
  assign level2 = _1_;
  assign level3 = _2_;
  assign level4 = _3_;
  assign level5 = _4_;
  assign level6 = _5_;
  assign r = level6[72:0];
endmodule

module lzc_26_comb_uid6(i, o);
  wire _00_;
  wire _01_;
  wire [14:0] _02_;
  wire _03_;
  wire _04_;
  wire [6:0] _05_;
  wire _06_;
  wire _07_;
  wire [2:0] _08_;
  wire _09_;
  wire _10_;
  wire _11_;
  wire _12_;
  wire [1:0] _13_;
  wire digit2;
  wire digit3;
  wire digit4;
  input [25:0] i;
  wire [25:0] i;
  wire [2:0] level2;
  wire [6:0] level3;
  wire [14:0] level4;
  wire [30:0] level5;
  wire [1:0] lowbits;
  output [4:0] o;
  wire [4:0] o;
  wire [2:0] outhighbits;
  assign _00_ = level5[30:15] == 16'h0000;
  assign _01_ = _00_ ? 1'h1 : 1'h0;
  assign _02_ = digit4 ? level5[14:0] : level5[30:16];
  assign _03_ = level4[14:7] == 8'h00;
  assign _04_ = _03_ ? 1'h1 : 1'h0;
  assign _05_ = digit3 ? level4[6:0] : level4[14:8];
  assign _06_ = level3[6:3] == 4'h0;
  assign _07_ = _06_ ? 1'h1 : 1'h0;
  assign _08_ = digit2 ? level3[2:0] : level3[6:4];
  assign _09_ = level2 == 3'h0;
  assign _10_ = level2 == 3'h1;
  assign _11_ = level2 == 3'h2;
  assign _12_ = level2 == 3'h3;
  function [1:0] \:558 ;
    input [1:0] a;
    input [7:0] b;
    input [3:0] s;
    casez (s) // synopsys parallel_case
      4'b???1:
        \:558  = b[1:0];
      4'b??1?:
        \:558  = b[3:2];
      4'b?1??:
        \:558  = b[5:4];
      4'b1???:
        \:558  = b[7:6];
      default:
        \:558  = a;
    endcase
  endfunction
  assign _13_ = \:558 (2'h0, 8'h5b, { _12_, _11_, _10_, _09_ });
  assign level5 = { i, 5'h1f };
  assign digit4 = _01_;
  assign level4 = _02_;
  assign digit3 = _04_;
  assign level3 = _05_;
  assign digit2 = _07_;
  assign level2 = _08_;
  assign lowbits = _13_;
  assign outhighbits = { digit4, digit3, digit2 };
  assign o = { outhighbits, lowbits };
endmodule

module rightshifter11_by_max_37_comb_uid4(x, s, r);
  wire [11:0] _0_;
  wire [13:0] _1_;
  wire [17:0] _2_;
  wire [25:0] _3_;
  wire [41:0] _4_;
  wire [73:0] _5_;
  wire [10:0] level0;
  wire [11:0] level1;
  wire [13:0] level2;
  wire [17:0] level3;
  wire [25:0] level4;
  wire [41:0] level5;
  wire [73:0] level6;
  wire [5:0] ps;
  output [47:0] r;
  wire [47:0] r;
  input [5:0] s;
  wire [5:0] s;
  input [10:0] x;
  wire [10:0] x;
  assign _0_ = ps[0] ? { 1'h0, level0 } : { level0, 1'h0 };
  assign _1_ = ps[1] ? { 2'h0, level1 } : { level1, 2'h0 };
  assign _2_ = ps[2] ? { 4'h0, level2 } : { level2, 4'h0 };
  assign _3_ = ps[3] ? { 8'h00, level3 } : { level3, 8'h00 };
  assign _4_ = ps[4] ? { 16'h0000, level4 } : { level4, 16'h0000 };
  assign _5_ = ps[5] ? { 32'h00000000, level5 } : { level5, 32'h00000000 };
  assign ps = s;
  assign level0 = x;
  assign level1 = _0_;
  assign level2 = _1_;
  assign level3 = _2_;
  assign level4 = _3_;
  assign level5 = _4_;
  assign level6 = _5_;
  assign r = level6[73:26];
endmodule

// Auto-generated by npu/rtlgen/gen.py (v0.1)
module npu_fp16_cpp_l1 (
    input  wire                  clk,
    input  wire                  rst_n,
    input  wire [11:0] mmio_addr,
    input  wire                  mmio_we,
    input  wire [31:0] mmio_wdata,
    output reg  [31:0] mmio_rdata,
    output reg                   irq,
    output reg                   dma_req_valid,
    output reg  [63:0] dma_req_src,
    output reg  [63:0] dma_req_dst,
    output reg  [31:0]           dma_req_bytes,
    input  wire                  dma_req_ready,
    input  wire                  dma_resp_done
,
    output reg  [63:0] cq_mem_addr,
    input  wire [255:0]          cq_mem_rdata
,
    output reg                   m_axi_awvalid,
    input  wire                  m_axi_awready,
    output reg  [63:0] m_axi_awaddr,
    output reg  [7:0]            m_axi_awlen,
    output reg  [2:0]            m_axi_awsize,
    output reg                   m_axi_wvalid,
    input  wire                  m_axi_wready,
    output reg  [255:0] m_axi_wdata,
    output reg  [31:0] m_axi_wstrb,
    output reg                   m_axi_wlast,
    input  wire                  m_axi_bvalid,
    output reg                   m_axi_bready,
    output reg                   m_axi_arvalid,
    input  wire                  m_axi_arready,
    output reg  [63:0] m_axi_araddr,
    output reg  [7:0]            m_axi_arlen,
    output reg  [2:0]            m_axi_arsize,
    input  wire                  m_axi_rvalid,
    output reg                   m_axi_rready,
    input  wire [255:0] m_axi_rdata,
    input  wire                  m_axi_rlast

);

  // Minimal stub: MMIO register block with queue bookkeeping.
  reg [31:0] version;
  reg [31:0] capabilities;
  reg [31:0] status;
  reg [31:0] control;
  reg [31:0] irq_status;
  reg [31:0] irq_enable;
  reg [31:0] cq_base_lo;
  reg [31:0] cq_base_hi;
  reg [31:0] cq_size;
  reg [31:0] cq_head;
  reg [31:0] cq_tail;
  reg [31:0] cq_count;
  reg [255:0] cq_word0;
  reg [7:0]  cq_word0_size;
  reg        cq_pending_ext;
  reg [7:0] last_opcode;
  reg [31:0] last_tag;
  reg [63:0] last_src;
  reg [63:0] last_dst;
  reg [31:0] last_size;
  reg [63:0] last_op_uid;
  reg [63:0] dma_src;
  reg [63:0] dma_dst;
  reg [31:0] dma_size;
  reg        cq_stage_valid;
  reg        dma_pending;
  reg [2:0]  dma_state;
  reg        gemm_pending;
  reg [1:0]  gemm_slot_valid;
  reg [1:0]  gemm_slot_done;
  reg [31:0] gemm_slot_cycles0;
  reg [31:0] gemm_slot_cycles1;
  reg [63:0] gemm_slot_uid0;
  reg [63:0] gemm_slot_uid1;
  reg [63:0] gemm_slot_src0;
  reg [63:0] gemm_slot_src1;
  reg [63:0] gemm_slot_dst0;
  reg [63:0] gemm_slot_dst1;
  reg [31:0] gemm_slot_size0;
  reg [31:0] gemm_slot_size1;
  reg [8:0]  gemm_slot_beats0;
  reg [8:0]  gemm_slot_beats1;
  reg [7:0]  gemm_slot_arlen0;
  reg [7:0]  gemm_slot_arlen1;
  reg        gemm_dma_sel;
  reg        gemm_done_pulse;
  reg [63:0] gemm_done_uid;
  reg [15:0] gemm_mac_a_vec0;
  reg [15:0] gemm_mac_b_vec0;
  reg [15:0] gemm_mac_a_vec1;
  reg [15:0] gemm_mac_b_vec1;
  reg signed [15:0] gemm_slot_accum0;
  reg signed [15:0] gemm_slot_accum1;
  reg [7:0] vec_in0;
  reg [7:0] vec_in1;
  reg [7:0] vec_last_result;
  reg [3:0] vec_op_sel;
  reg [3:0] vec_dtype_sel;
  reg vec_pending;
  reg vec_done_pulse;
  reg [255:0] dma_buf;
  reg [8:0]  dma_beats;
  reg [8:0]  dma_beats_left;
  reg [7:0]  dma_arlen;
  reg [255:0] dma_buf_mem [0:255];
  reg [7:0]  dma_rd_idx;
  reg [7:0]  dma_wr_idx;
  reg [31:0] error_code;

  localparam STATUS_IDLE = 32'h1;
  localparam STATUS_BUSY = 32'h2;
  localparam STATUS_ERR  = 32'h4;

  localparam integer AXI_BEAT_BYTES = 32;

  localparam IRQ_CQ_EMPTY    = 0;
  localparam IRQ_EVENT       = 1;
  localparam IRQ_ERROR       = 2;
  localparam [3:0] VEC_OP_RELU      = 4'h0;
  localparam [3:0] VEC_OP_ADD       = 4'h1;
  localparam [3:0] VEC_OP_MUL       = 4'h2;
  localparam [3:0] VEC_OP_GELU      = 4'h3;
  localparam [3:0] VEC_OP_SOFTMAX   = 4'h4;
  localparam [3:0] VEC_OP_LAYERNORM = 4'h5;
  localparam [3:0] VEC_OP_DRELU     = 4'h6;
  localparam [3:0] VEC_OP_DGELU     = 4'h7;
  localparam [3:0] VEC_OP_DSOFTMAX  = 4'h8;
  localparam [3:0] VEC_OP_DLAYERNORM= 4'h9;
  localparam [3:0] VEC_DTYPE_INT8   = 4'h0;
  localparam [3:0] VEC_DTYPE_FP16   = 4'h1;
  localparam       VEC_EN_ADD       = 1;
  localparam       VEC_EN_MUL       = 1;
  localparam       VEC_EN_RELU      = 1;
  localparam       VEC_EN_GELU      = 0;
  localparam       VEC_EN_SOFTMAX   = 0;
  localparam       VEC_EN_LAYERNORM = 0;
  localparam       VEC_EN_DRELU     = 0;
  localparam       VEC_EN_DGELU     = 0;
  localparam       VEC_EN_DSOFTMAX  = 0;
  localparam       VEC_EN_DLAYERNORM= 0;
  localparam       VEC_FP16_ENABLED = 0;
  localparam integer GEMM_MAC_LANES = 1;
  localparam integer GEMM_ELEM_BITS = 16;
  localparam integer GEMM_FP16_RAW16_PLACEHOLDER = 0;
  localparam integer GEMM_FP16_ACCUM_FP32 = 0;
  localparam integer VEC_LANES      = 1;

  // MMIO offsets (bytes)
  `include "mmio_map.vh"

  wire [15:0] gemm_mac_next0;
  wire [15:0] gemm_mac_next1;

  gemm_mac_fp16_ieee u_gemm_mac0 (
    .A(gemm_mac_a_vec0[15:0]),
    .B(gemm_mac_b_vec0[15:0]),
    .C(gemm_slot_accum0[15:0]),
    .negateAB(1'b0),
    .negateC(1'b0),
    .RndMode(2'b00),
    .R(gemm_mac_next0)
  );

  gemm_mac_fp16_ieee u_gemm_mac1 (
    .A(gemm_mac_a_vec1[15:0]),
    .B(gemm_mac_b_vec1[15:0]),
    .C(gemm_slot_accum1[15:0]),
    .negateAB(1'b0),
    .negateC(1'b0),
    .RndMode(2'b00),
    .R(gemm_mac_next1)
  );

  wire [7:0] vec_add_res;
  wire [7:0] vec_mul_res;
  wire [7:0] vec_relu_res;
  wire [7:0] vec_gelu_res;
  wire [7:0] vec_softmax_res;
  wire [7:0] vec_layernorm_res;
  wire [7:0] vec_drelu_res;
  wire [7:0] vec_dgelu_res;
  wire [7:0] vec_dsoftmax_res;
  wire [7:0] vec_dlayernorm_res;
  wire [7:0] vec_result_next_int8;
  wire [7:0] vec_result_next_fp16;
  wire [7:0] vec_result_next;
  wire vec_dtype_is_fp16;

  genvar gi;
  generate
    for (gi = 0; gi < 1; gi = gi + 1) begin : g_vec_lane
      assign vec_add_res[(gi*8) +: 8] = $signed(vec_in0[(gi*8) +: 8]) + $signed(vec_in1[(gi*8) +: 8]);
      assign vec_mul_res[(gi*8) +: 8] = $signed(vec_in0[(gi*8) +: 8]) * $signed(vec_in1[(gi*8) +: 8]);
      assign vec_relu_res[(gi*8) +: 8] = vec_in0[(gi*8)+7] ? 8'h00 : vec_in0[(gi*8) +: 8];
      assign vec_gelu_res[(gi*8) +: 8] = vec_in0[(gi*8)+7] ? 8'h00 : ($signed(vec_in0[(gi*8) +: 8]) >>> 1);
      assign vec_softmax_res[(gi*8) +: 8] = vec_in0[(gi*8)+7] ? 8'h00 : (($signed(vec_in0[(gi*8) +: 8]) > 8'sd31) ? 8'd127 : (vec_in0[(gi*8) +: 8] << 2));
      assign vec_layernorm_res[(gi*8) +: 8] = $signed(vec_in0[(gi*8) +: 8]) >>> 1;
      assign vec_drelu_res[(gi*8) +: 8] = ($signed(vec_in0[(gi*8) +: 8]) > 0) ? 8'h01 : 8'h00;
      assign vec_dgelu_res[(gi*8) +: 8] = ($signed(vec_in0[(gi*8) +: 8]) > 0) ? 8'h01 : 8'h00;
      wire [7:0] vec_dsoftmax_p = vec_softmax_res[(gi*8) +: 8];
      wire [15:0] vec_dsoftmax_mul = vec_dsoftmax_p * (8'd127 - vec_dsoftmax_p);
      assign vec_dsoftmax_res[(gi*8) +: 8] = vec_dsoftmax_mul[14:7];
      assign vec_dlayernorm_res[(gi*8) +: 8] = 8'h01;
    end
  endgenerate


  wire [7:0] vec_add_res_fp16 = {8{1'b0}};
  wire [7:0] vec_mul_res_fp16 = {8{1'b0}};
  wire [7:0] vec_relu_res_fp16 = {8{1'b0}};
  wire [7:0] vec_gelu_res_fp16 = {8{1'b0}};
  wire [7:0] vec_softmax_res_fp16 = {8{1'b0}};
  wire [7:0] vec_layernorm_res_fp16 = {8{1'b0}};
  wire [7:0] vec_drelu_res_fp16 = {8{1'b0}};
  wire [7:0] vec_dgelu_res_fp16 = {8{1'b0}};
  wire [7:0] vec_dsoftmax_res_fp16 = {8{1'b0}};
  wire [7:0] vec_dlayernorm_res_fp16 = {8{1'b0}};

  assign vec_dtype_is_fp16 = (vec_dtype_sel == VEC_DTYPE_FP16);

  assign vec_result_next_int8 = (vec_op_sel == VEC_OP_ADD) ? vec_add_res :
                                (vec_op_sel == VEC_OP_MUL) ? vec_mul_res :
                                (vec_op_sel == VEC_OP_GELU) ? vec_gelu_res :
                                (vec_op_sel == VEC_OP_SOFTMAX) ? vec_softmax_res :
                                (vec_op_sel == VEC_OP_LAYERNORM) ? vec_layernorm_res :
                                (vec_op_sel == VEC_OP_DRELU) ? vec_drelu_res :
                                (vec_op_sel == VEC_OP_DGELU) ? vec_dgelu_res :
                                (vec_op_sel == VEC_OP_DSOFTMAX) ? vec_dsoftmax_res :
                                (vec_op_sel == VEC_OP_DLAYERNORM) ? vec_dlayernorm_res :
                                vec_relu_res;

  assign vec_result_next_fp16 = (vec_op_sel == VEC_OP_ADD) ? vec_add_res_fp16 :
                                (vec_op_sel == VEC_OP_MUL) ? vec_mul_res_fp16 :
                                (vec_op_sel == VEC_OP_GELU) ? vec_gelu_res_fp16 :
                                (vec_op_sel == VEC_OP_SOFTMAX) ? vec_softmax_res_fp16 :
                                (vec_op_sel == VEC_OP_LAYERNORM) ? vec_layernorm_res_fp16 :
                                (vec_op_sel == VEC_OP_DRELU) ? vec_drelu_res_fp16 :
                                (vec_op_sel == VEC_OP_DGELU) ? vec_dgelu_res_fp16 :
                                (vec_op_sel == VEC_OP_DSOFTMAX) ? vec_dsoftmax_res_fp16 :
                                (vec_op_sel == VEC_OP_DLAYERNORM) ? vec_dlayernorm_res_fp16 :
                                vec_relu_res_fp16;

  assign vec_result_next = vec_dtype_is_fp16 ? vec_result_next_fp16 : vec_result_next_int8;


  always @(*) begin
    case (mmio_addr)
      OFF_VERSION:    mmio_rdata = version;
      OFF_CAPS:       mmio_rdata = capabilities;
      OFF_STATUS:     mmio_rdata = status;
      OFF_CONTROL:    mmio_rdata = control;
      OFF_IRQ_STATUS: mmio_rdata = irq_status;
      OFF_IRQ_ENABLE: mmio_rdata = irq_enable;
      OFF_CQ_BASE_LO: mmio_rdata = cq_base_lo;
      OFF_CQ_BASE_HI: mmio_rdata = cq_base_hi;
      OFF_CQ_SIZE:    mmio_rdata = cq_size;
      OFF_CQ_HEAD:    mmio_rdata = cq_head;
      OFF_CQ_TAIL:    mmio_rdata = cq_tail;
      OFF_ERROR_CODE: mmio_rdata = error_code;
      default: mmio_rdata = 0;
    endcase
  end

  always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
      version <= 32'h0001_0001;
      capabilities <= 32'h0000_0133; // DMA_COPY/STRIDED/GATHER/SCATTER + GEMM/VEC/SOFTMAX + EVENT_IRQ
      status <= STATUS_IDLE;
      control <= 0;
      irq_status <= 0;
      irq_enable <= 0;
      cq_base_lo <= 0;
      cq_base_hi <= 0;
      cq_size <= 0;
      cq_head <= 0;
      cq_tail <= 0;
      cq_count <= 0;
      cq_word0 <= 0;
      cq_word0_size <= 0;
      cq_pending_ext <= 0;
      error_code <= 0;
      irq <= 0;
      last_opcode <= 0;
      last_tag <= 0;
      last_src <= 0;
      last_dst <= 0;
      last_size <= 0;
      last_op_uid <= 0;
      dma_src <= 0;
      dma_dst <= 0;
      dma_size <= 0;
      cq_stage_valid <= 0;
      dma_pending <= 0;
      dma_state <= 0;
      gemm_pending <= 0;
      gemm_slot_valid <= 0;
      gemm_slot_done <= 0;
      gemm_slot_cycles0 <= 0;
      gemm_slot_cycles1 <= 0;
      gemm_slot_uid0 <= 0;
      gemm_slot_uid1 <= 0;
      gemm_slot_src0 <= 0;
      gemm_slot_src1 <= 0;
      gemm_slot_dst0 <= 0;
      gemm_slot_dst1 <= 0;
      gemm_slot_size0 <= 0;
      gemm_slot_size1 <= 0;
      gemm_slot_beats0 <= 0;
      gemm_slot_beats1 <= 0;
      gemm_slot_arlen0 <= 0;
      gemm_slot_arlen1 <= 0;
      gemm_dma_sel <= 0;
      gemm_done_pulse <= 0;
      gemm_done_uid <= 0;
      gemm_mac_a_vec0 <= 0;
      gemm_mac_b_vec0 <= 0;
      gemm_mac_a_vec1 <= 0;
      gemm_mac_b_vec1 <= 0;
      gemm_slot_accum0 <= 0;
      gemm_slot_accum1 <= 0;
      vec_in0 <= 0;
      vec_in1 <= 0;
      vec_last_result <= 0;
      vec_op_sel <= 0;
      vec_dtype_sel <= 0;
      vec_pending <= 0;
      vec_done_pulse <= 0;
      dma_buf <= 0;
      dma_beats <= 0;
      dma_beats_left <= 0;
      dma_arlen <= 0;
      dma_rd_idx <= 0;
      dma_wr_idx <= 0;
      dma_req_valid <= 0;
      dma_req_src <= 0;
      dma_req_dst <= 0;
      dma_req_bytes <= 0;
      m_axi_awvalid <= 1'b0;
      m_axi_awaddr <= 0;
      m_axi_awlen <= 0;
      m_axi_awsize <= 0;
      m_axi_wvalid <= 1'b0;
      m_axi_wdata <= 0;
      m_axi_wstrb <= 0;
      m_axi_wlast <= 1'b0;
      m_axi_bready <= 1'b0;
      m_axi_arvalid <= 1'b0;
      m_axi_araddr <= 0;
      m_axi_arlen <= 0;
      m_axi_arsize <= 0;
      m_axi_rready <= 1'b0;
    end else begin
      // Default: clear level IRQ unless status bit set
      irq <= |(irq_status & irq_enable);
      if (dma_req_valid && dma_req_ready) begin
        dma_req_valid <= 0;
      end
      if (dma_resp_done) begin
        irq_status[IRQ_EVENT] <= 1'b1;
      end
      // Two-slot GEMM stub with OOO-capable completion scheduling.
      gemm_done_pulse <= 1'b0;
      vec_done_pulse <= 1'b0;
      if (vec_pending) begin
        vec_last_result <= vec_result_next;
        vec_pending <= 1'b0;
        vec_done_pulse <= 1'b1;
        irq_status[IRQ_EVENT] <= 1'b1;
      end
      if (gemm_slot_valid[0] && !gemm_slot_done[0]) begin
        gemm_slot_accum0 <= gemm_mac_next0;
      end
      if (gemm_slot_valid[1] && !gemm_slot_done[1]) begin
        gemm_slot_accum1 <= gemm_mac_next1;
      end
      if (gemm_slot_valid[0] && !gemm_slot_done[0]) begin
        if (gemm_slot_cycles0 != 0) begin
          gemm_slot_cycles0 <= gemm_slot_cycles0 - 1;
          if (gemm_slot_cycles0 == 1) begin
            gemm_slot_done[0] <= 1'b1;
            gemm_done_pulse <= 1'b1;
            gemm_done_uid <= gemm_slot_uid0;
          end
        end else begin
          gemm_slot_done[0] <= 1'b1;
          gemm_done_pulse <= 1'b1;
          gemm_done_uid <= gemm_slot_uid0;
        end
      end
      if (gemm_slot_valid[1] && !gemm_slot_done[1]) begin
        if (gemm_slot_cycles1 != 0) begin
          gemm_slot_cycles1 <= gemm_slot_cycles1 - 1;
          if (gemm_slot_cycles1 == 1) begin
            gemm_slot_done[1] <= 1'b1;
            gemm_done_pulse <= 1'b1;
            gemm_done_uid <= gemm_slot_uid1;
          end
        end else begin
          gemm_slot_done[1] <= 1'b1;
          gemm_done_pulse <= 1'b1;
          gemm_done_uid <= gemm_slot_uid1;
        end
      end
      // Prefer slot1 if both are done, so completion order can differ from issue order.
      if (!dma_pending) begin
        if (gemm_slot_done[1]) begin
          dma_src <= gemm_slot_src1;
          dma_dst <= gemm_slot_dst1;
          dma_size <= gemm_slot_size1;
          dma_beats <= gemm_slot_beats1;
          dma_arlen <= gemm_slot_arlen1;
          dma_pending <= 1'b1;
          gemm_slot_valid[1] <= 1'b0;
          gemm_slot_done[1] <= 1'b0;
          gemm_dma_sel <= 1'b1;
        end else if (gemm_slot_done[0]) begin
          dma_src <= gemm_slot_src0;
          dma_dst <= gemm_slot_dst0;
          dma_size <= gemm_slot_size0;
          dma_beats <= gemm_slot_beats0;
          dma_arlen <= gemm_slot_arlen0;
          dma_pending <= 1'b1;
          gemm_slot_valid[0] <= 1'b0;
          gemm_slot_done[0] <= 1'b0;
          gemm_dma_sel <= 1'b0;
        end
      end
      gemm_pending <= (gemm_slot_valid != 2'b00);
      m_axi_awvalid <= 1'b0;
      m_axi_awaddr <= 0;
      m_axi_awlen <= 0;
      m_axi_awsize <= 0;
      m_axi_wvalid <= 1'b0;
      m_axi_wdata <= 0;
      m_axi_wstrb <= 0;
      m_axi_wlast <= 1'b0;
      m_axi_bready <= 1'b0;
      m_axi_arvalid <= 1'b0;
      m_axi_araddr <= 0;
      m_axi_arlen <= 0;
      m_axi_arsize <= 0;
      m_axi_rready <= 1'b0;
      // AXI DMA shim: burst read then burst write.
      case (dma_state)
        0: begin
          if (dma_pending) begin
            if (dma_beats_left == 0) begin
              dma_beats_left <= dma_beats;
              dma_rd_idx <= 0;
              dma_wr_idx <= 0;
            end
            m_axi_arvalid <= 1'b1;
            m_axi_araddr <= dma_src;
            m_axi_arlen <= dma_arlen;
            m_axi_arsize <= 3'd5; // beat bytes = 2**5
            if (m_axi_arready) begin
              dma_state <= 1;
            end
          end
        end
        1: begin
          m_axi_rready <= 1'b1;
          if (m_axi_rvalid) begin
            dma_buf_mem[dma_rd_idx] <= m_axi_rdata;
            dma_rd_idx <= dma_rd_idx + 1;
            if (m_axi_rlast) begin
              dma_state <= 2;
            end
          end
        end
        2: begin
          m_axi_awvalid <= 1'b1;
          m_axi_awaddr <= dma_dst;
          m_axi_awlen <= dma_arlen;
          m_axi_awsize <= 3'd5;
          if (m_axi_awready) begin
            dma_state <= 3;
          end
        end
        3: begin
          m_axi_wvalid <= 1'b1;
          m_axi_wdata <= dma_buf_mem[dma_wr_idx];
          m_axi_wstrb <= {32{1'b1}};
          m_axi_wlast <= (dma_beats_left == 1);
          if (m_axi_wready) begin
            if (dma_beats_left == 1) begin
              dma_state <= 4;
            end else begin
              dma_wr_idx <= dma_wr_idx + 1;
              dma_beats_left <= dma_beats_left - 1;
            end
          end
        end
        4: begin
          m_axi_bready <= 1'b1;
          if (m_axi_bvalid) begin
            dma_beats_left <= 0;
            dma_state <= 0;
            dma_pending <= 1'b0;
            irq_status[IRQ_EVENT] <= 1'b1;
          end
        end
        default: dma_state <= 0;
      endcase

      if (mmio_we) begin
        case (mmio_addr)
          OFF_CONTROL: control <= mmio_wdata;
          OFF_IRQ_STATUS: irq_status <= irq_status & ~mmio_wdata; // W1C
          OFF_IRQ_ENABLE: irq_enable <= mmio_wdata;
          OFF_CQ_BASE_LO: cq_base_lo <= mmio_wdata;
          OFF_CQ_BASE_HI: cq_base_hi <= mmio_wdata;
          OFF_CQ_SIZE:    cq_size <= mmio_wdata;
          OFF_CQ_TAIL:    cq_tail <= mmio_wdata;
          OFF_DOORBELL: begin
            // Minimal behavior: consume all queued descriptors.
            cq_count <= ((cq_tail - cq_head) >> 5);
            if (((cq_tail - cq_head) >> 5) == 0) begin
              status <= STATUS_IDLE;
              irq_status[IRQ_CQ_EMPTY] <= 1'b1;
            end else begin
              status <= STATUS_BUSY;
            end
            // DMA request will be issued when DMA_COPY descriptor is fetched.
          end
          default: begin end
        endcase
      end

      // Command queue fetch (supports v0.1 32B and v0.2 64B descriptors).
      if (cq_count != 0) begin
        if (!cq_stage_valid && !cq_pending_ext) begin
          cq_mem_addr <= {cq_base_hi, cq_base_lo} + cq_head;
          cq_stage_valid <= 1'b1;
        end else if (cq_stage_valid && !cq_pending_ext) begin
          cq_word0 <= cq_mem_rdata;
          cq_word0_size <= cq_mem_rdata[23:16];
          if (cq_mem_rdata[23:16] >= 8'h02) begin
            cq_pending_ext <= 1'b1;
            cq_stage_valid <= 1'b0;
          end else begin
            last_opcode <= cq_mem_rdata[7:0];
            last_tag <= cq_mem_rdata[63:32];
            last_src <= cq_mem_rdata[127:64];
            last_dst <= cq_mem_rdata[191:128];
            last_size <= cq_mem_rdata[223:192];
            last_op_uid <= 0;
            if (cq_mem_rdata[7:0] == 8'h01) begin
              dma_req_valid <= 1'b1;
              dma_req_src <= cq_mem_rdata[127:64];
              dma_req_dst <= cq_mem_rdata[191:128];
              dma_req_bytes <= cq_mem_rdata[223:192];
              dma_src <= cq_mem_rdata[127:64];
              dma_dst <= cq_mem_rdata[191:128];
              dma_size <= cq_mem_rdata[223:192];
              dma_beats <= (cq_mem_rdata[223:197] + (|cq_mem_rdata[196:192]));
              dma_arlen <= (cq_mem_rdata[223:197] + (|cq_mem_rdata[196:192])) - 1;
              dma_pending <= 1'b1;
            end else if (cq_mem_rdata[7:0] == 8'h10) begin
              // GEMM stub: v0.1 sizes packed in TAG.
              if (!gemm_slot_valid[0]) begin
                gemm_slot_valid[0] <= 1'b1;
                gemm_slot_done[0] <= 1'b0;
                gemm_slot_uid0 <= 64'h0;
                gemm_mac_a_vec0 <= cq_mem_rdata[79:64];
                gemm_mac_b_vec0 <= cq_mem_rdata[143:128];
                gemm_slot_accum0 <= 0;
                if ((cq_mem_rdata[63:52] == 0) || (cq_mem_rdata[51:42] == 0) || (cq_mem_rdata[41:32] == 0)) begin
                  gemm_slot_cycles0 <= 1;
                end else begin
                  gemm_slot_cycles0 <= (((cq_mem_rdata[63:52] * cq_mem_rdata[51:42] * cq_mem_rdata[41:32]) >> 10) + 1);
                end
                gemm_slot_src0 <= cq_mem_rdata[127:64];
                gemm_slot_dst0 <= cq_mem_rdata[255:192];
                gemm_slot_size0 <= ((cq_mem_rdata[11:8] == 4'h1 || cq_mem_rdata[11:8] == 4'h2)
                                    ? (cq_mem_rdata[63:52] * cq_mem_rdata[51:42] * 2)
                                    : (cq_mem_rdata[63:52] * cq_mem_rdata[51:42]));
                gemm_slot_beats0 <= (((((cq_mem_rdata[11:8] == 4'h1 || cq_mem_rdata[11:8] == 4'h2)
                                        ? (cq_mem_rdata[63:52] * cq_mem_rdata[51:42] * 2)
                                        : (cq_mem_rdata[63:52] * cq_mem_rdata[51:42]))
                                       + AXI_BEAT_BYTES - 1) >> 5));
                gemm_slot_arlen0 <= (((((cq_mem_rdata[11:8] == 4'h1 || cq_mem_rdata[11:8] == 4'h2)
                                        ? (cq_mem_rdata[63:52] * cq_mem_rdata[51:42] * 2)
                                        : (cq_mem_rdata[63:52] * cq_mem_rdata[51:42]))
                                       + AXI_BEAT_BYTES - 1) >> 5) - 1);
              end else if (!gemm_slot_valid[1]) begin
                gemm_slot_valid[1] <= 1'b1;
                gemm_slot_done[1] <= 1'b0;
                gemm_slot_uid1 <= 64'h0;
                gemm_mac_a_vec1 <= cq_mem_rdata[79:64];
                gemm_mac_b_vec1 <= cq_mem_rdata[143:128];
                gemm_slot_accum1 <= 0;
                if ((cq_mem_rdata[63:52] == 0) || (cq_mem_rdata[51:42] == 0) || (cq_mem_rdata[41:32] == 0)) begin
                  gemm_slot_cycles1 <= 1;
                end else begin
                  gemm_slot_cycles1 <= (((cq_mem_rdata[63:52] * cq_mem_rdata[51:42] * cq_mem_rdata[41:32]) >> 10) + 1);
                end
                gemm_slot_src1 <= cq_mem_rdata[127:64];
                gemm_slot_dst1 <= cq_mem_rdata[255:192];
                gemm_slot_size1 <= ((cq_mem_rdata[11:8] == 4'h1 || cq_mem_rdata[11:8] == 4'h2)
                                    ? (cq_mem_rdata[63:52] * cq_mem_rdata[51:42] * 2)
                                    : (cq_mem_rdata[63:52] * cq_mem_rdata[51:42]));
                gemm_slot_beats1 <= (((((cq_mem_rdata[11:8] == 4'h1 || cq_mem_rdata[11:8] == 4'h2)
                                        ? (cq_mem_rdata[63:52] * cq_mem_rdata[51:42] * 2)
                                        : (cq_mem_rdata[63:52] * cq_mem_rdata[51:42]))
                                       + AXI_BEAT_BYTES - 1) >> 5));
                gemm_slot_arlen1 <= (((((cq_mem_rdata[11:8] == 4'h1 || cq_mem_rdata[11:8] == 4'h2)
                                        ? (cq_mem_rdata[63:52] * cq_mem_rdata[51:42] * 2)
                                        : (cq_mem_rdata[63:52] * cq_mem_rdata[51:42]))
                                       + AXI_BEAT_BYTES - 1) >> 5) - 1);
              end else begin
                error_code <= 32'h2; // GEMM in-flight queue full
              end
            end else if (cq_mem_rdata[7:0] == 8'h11) begin
              // VEC_OP (v0.1): input vectors are carried in descriptor payload bytes.
              if (vec_pending) begin
                error_code <= 32'h3; // VEC in-flight queue full
              end else begin
                vec_in0 <= cq_mem_rdata[71:64];
                vec_in1 <= cq_mem_rdata[135:128];
                vec_op_sel <= cq_mem_rdata[11:8];
                vec_dtype_sel <= cq_mem_rdata[15:12];
                if (((cq_mem_rdata[15:12] == VEC_DTYPE_FP16) && !VEC_FP16_ENABLED) ||
                    ((cq_mem_rdata[15:12] != VEC_DTYPE_INT8) && (cq_mem_rdata[15:12] != VEC_DTYPE_FP16)) ||
                    ((cq_mem_rdata[15:12] == VEC_DTYPE_FP16) &&
                     (cq_mem_rdata[11:8] != VEC_OP_RELU) &&
                     (cq_mem_rdata[11:8] != VEC_OP_ADD) &&
                     (cq_mem_rdata[11:8] != VEC_OP_MUL) &&
                     (cq_mem_rdata[11:8] != VEC_OP_GELU) &&
                     (cq_mem_rdata[11:8] != VEC_OP_SOFTMAX) &&
                     (cq_mem_rdata[11:8] != VEC_OP_LAYERNORM) &&
                     (cq_mem_rdata[11:8] != VEC_OP_DRELU) &&
                     (cq_mem_rdata[11:8] != VEC_OP_DGELU) &&
                     (cq_mem_rdata[11:8] != VEC_OP_DSOFTMAX) &&
                     (cq_mem_rdata[11:8] != VEC_OP_DLAYERNORM)) ||
                    (cq_mem_rdata[11:8] == VEC_OP_ADD       && !VEC_EN_ADD)       ||
                    (cq_mem_rdata[11:8] == VEC_OP_MUL       && !VEC_EN_MUL)       ||
                    (cq_mem_rdata[11:8] == VEC_OP_RELU      && !VEC_EN_RELU)      ||
                    (cq_mem_rdata[11:8] == VEC_OP_GELU      && !VEC_EN_GELU)      ||
                    (cq_mem_rdata[11:8] == VEC_OP_SOFTMAX   && !VEC_EN_SOFTMAX)   ||
                    (cq_mem_rdata[11:8] == VEC_OP_LAYERNORM && !VEC_EN_LAYERNORM) ||
                    (cq_mem_rdata[11:8] == VEC_OP_DRELU     && !VEC_EN_DRELU)     ||
                    (cq_mem_rdata[11:8] == VEC_OP_DGELU     && !VEC_EN_DGELU)     ||
                    (cq_mem_rdata[11:8] == VEC_OP_DSOFTMAX  && !VEC_EN_DSOFTMAX)  ||
                    (cq_mem_rdata[11:8] == VEC_OP_DLAYERNORM&& !VEC_EN_DLAYERNORM)||
                    ((cq_mem_rdata[11:8] != VEC_OP_RELU)      &&
                     (cq_mem_rdata[11:8] != VEC_OP_ADD)       &&
                     (cq_mem_rdata[11:8] != VEC_OP_MUL)       &&
                     (cq_mem_rdata[11:8] != VEC_OP_GELU)      &&
                     (cq_mem_rdata[11:8] != VEC_OP_SOFTMAX)   &&
                     (cq_mem_rdata[11:8] != VEC_OP_LAYERNORM) &&
                     (cq_mem_rdata[11:8] != VEC_OP_DRELU)     &&
                     (cq_mem_rdata[11:8] != VEC_OP_DGELU)     &&
                     (cq_mem_rdata[11:8] != VEC_OP_DSOFTMAX)  &&
                     (cq_mem_rdata[11:8] != VEC_OP_DLAYERNORM))) begin
                  error_code <= 32'h6; // unsupported configured VEC op
                end else begin
                  vec_pending <= 1'b1;
                end
              end
            end else if (cq_mem_rdata[7:0] == 8'h20) begin
              // EVENT_SIGNAL: immediately signal
              irq_status[IRQ_EVENT] <= 1'b1;
            end else if (cq_mem_rdata[7:0] == 8'h21) begin
              // EVENT_WAIT: stubbed as immediately satisfied
              irq_status[IRQ_EVENT] <= 1'b1;
            end else begin
              error_code <= 32'h1;
            end
            cq_head <= cq_head + 32;
            if (cq_count == 1) begin
              irq_status[IRQ_CQ_EMPTY] <= 1'b1;
            end
            cq_count <= cq_count - 1;
            cq_stage_valid <= 1'b0;
          end
        end else if (cq_pending_ext) begin
          if (!cq_stage_valid) begin
            cq_mem_addr <= {cq_base_hi, cq_base_lo} + cq_head + 32;
            cq_stage_valid <= 1'b1;
          end else begin
            last_opcode <= cq_word0[7:0];
            last_tag <= cq_word0[63:32];
            last_src <= cq_word0[127:64];
            last_dst <= cq_word0[191:128];
            last_size <= cq_mem_rdata[31:0];
            last_op_uid <= cq_mem_rdata[255:192];
            if (cq_word0[7:0] == 8'h10) begin
              // GEMM stub: v0.2 sizes in extension.
              if (!gemm_slot_valid[0]) begin
                gemm_slot_valid[0] <= 1'b1;
                gemm_slot_done[0] <= 1'b0;
                gemm_slot_uid0 <= cq_mem_rdata[255:192];
                gemm_mac_a_vec0 <= cq_word0[79:64];
                gemm_mac_b_vec0 <= cq_word0[143:128];
                gemm_slot_accum0 <= 0;
                if ((cq_mem_rdata[31:0] == 0) || (cq_mem_rdata[63:32] == 0) || (cq_mem_rdata[95:64] == 0)) begin
                  gemm_slot_cycles0 <= 1;
                end else begin
                  // Optional UID-based jitter (bit63) to exercise OOO completion in tests.
                  gemm_slot_cycles0 <= (((cq_mem_rdata[31:0] * cq_mem_rdata[63:32] * cq_mem_rdata[95:64]) >> 10)
                                        + 1 + (cq_mem_rdata[255] ? 8 : 0));
                end
                gemm_slot_src0 <= cq_word0[127:64];
                gemm_slot_dst0 <= cq_word0[255:192];
                gemm_slot_size0 <= ((cq_word0[11:8] == 4'h1 || cq_word0[11:8] == 4'h2)
                                    ? (cq_mem_rdata[31:0] * cq_mem_rdata[63:32] * 2)
                                    : (cq_mem_rdata[31:0] * cq_mem_rdata[63:32]));
                gemm_slot_beats0 <= (((((cq_word0[11:8] == 4'h1 || cq_word0[11:8] == 4'h2)
                                        ? (cq_mem_rdata[31:0] * cq_mem_rdata[63:32] * 2)
                                        : (cq_mem_rdata[31:0] * cq_mem_rdata[63:32]))
                                       + AXI_BEAT_BYTES - 1) >> 5));
                gemm_slot_arlen0 <= (((((cq_word0[11:8] == 4'h1 || cq_word0[11:8] == 4'h2)
                                        ? (cq_mem_rdata[31:0] * cq_mem_rdata[63:32] * 2)
                                        : (cq_mem_rdata[31:0] * cq_mem_rdata[63:32]))
                                       + AXI_BEAT_BYTES - 1) >> 5) - 1);
              end else if (!gemm_slot_valid[1]) begin
                gemm_slot_valid[1] <= 1'b1;
                gemm_slot_done[1] <= 1'b0;
                gemm_slot_uid1 <= cq_mem_rdata[255:192];
                gemm_mac_a_vec1 <= cq_word0[79:64];
                gemm_mac_b_vec1 <= cq_word0[143:128];
                gemm_slot_accum1 <= 0;
                if ((cq_mem_rdata[31:0] == 0) || (cq_mem_rdata[63:32] == 0) || (cq_mem_rdata[95:64] == 0)) begin
                  gemm_slot_cycles1 <= 1;
                end else begin
                  gemm_slot_cycles1 <= (((cq_mem_rdata[31:0] * cq_mem_rdata[63:32] * cq_mem_rdata[95:64]) >> 10)
                                        + 1 + (cq_mem_rdata[255] ? 8 : 0));
                end
                gemm_slot_src1 <= cq_word0[127:64];
                gemm_slot_dst1 <= cq_word0[255:192];
                gemm_slot_size1 <= ((cq_word0[11:8] == 4'h1 || cq_word0[11:8] == 4'h2)
                                    ? (cq_mem_rdata[31:0] * cq_mem_rdata[63:32] * 2)
                                    : (cq_mem_rdata[31:0] * cq_mem_rdata[63:32]));
                gemm_slot_beats1 <= (((((cq_word0[11:8] == 4'h1 || cq_word0[11:8] == 4'h2)
                                        ? (cq_mem_rdata[31:0] * cq_mem_rdata[63:32] * 2)
                                        : (cq_mem_rdata[31:0] * cq_mem_rdata[63:32]))
                                       + AXI_BEAT_BYTES - 1) >> 5));
                gemm_slot_arlen1 <= (((((cq_word0[11:8] == 4'h1 || cq_word0[11:8] == 4'h2)
                                        ? (cq_mem_rdata[31:0] * cq_mem_rdata[63:32] * 2)
                                        : (cq_mem_rdata[31:0] * cq_mem_rdata[63:32]))
                                       + AXI_BEAT_BYTES - 1) >> 5) - 1);
              end else begin
                error_code <= 32'h2; // GEMM in-flight queue full
              end
            end else if (cq_word0[7:0] == 8'h11) begin
              // VEC_OP (v0.2 base word): vectors are sourced from header payload.
              if (vec_pending) begin
                error_code <= 32'h3; // VEC in-flight queue full
              end else begin
                vec_in0 <= cq_word0[71:64];
                vec_in1 <= cq_word0[135:128];
                vec_op_sel <= cq_word0[11:8];
                vec_dtype_sel <= cq_word0[15:12];
                if (((cq_word0[15:12] == VEC_DTYPE_FP16) && !VEC_FP16_ENABLED) ||
                    ((cq_word0[15:12] != VEC_DTYPE_INT8) && (cq_word0[15:12] != VEC_DTYPE_FP16)) ||
                    ((cq_word0[15:12] == VEC_DTYPE_FP16) &&
                     (cq_word0[11:8] != VEC_OP_RELU) &&
                     (cq_word0[11:8] != VEC_OP_ADD) &&
                     (cq_word0[11:8] != VEC_OP_MUL) &&
                     (cq_word0[11:8] != VEC_OP_GELU) &&
                     (cq_word0[11:8] != VEC_OP_SOFTMAX) &&
                     (cq_word0[11:8] != VEC_OP_LAYERNORM) &&
                     (cq_word0[11:8] != VEC_OP_DRELU) &&
                     (cq_word0[11:8] != VEC_OP_DGELU) &&
                     (cq_word0[11:8] != VEC_OP_DSOFTMAX) &&
                     (cq_word0[11:8] != VEC_OP_DLAYERNORM)) ||
                    (cq_word0[11:8] == VEC_OP_ADD       && !VEC_EN_ADD)       ||
                    (cq_word0[11:8] == VEC_OP_MUL       && !VEC_EN_MUL)       ||
                    (cq_word0[11:8] == VEC_OP_RELU      && !VEC_EN_RELU)      ||
                    (cq_word0[11:8] == VEC_OP_GELU      && !VEC_EN_GELU)      ||
                    (cq_word0[11:8] == VEC_OP_SOFTMAX   && !VEC_EN_SOFTMAX)   ||
                    (cq_word0[11:8] == VEC_OP_LAYERNORM && !VEC_EN_LAYERNORM) ||
                    (cq_word0[11:8] == VEC_OP_DRELU     && !VEC_EN_DRELU)     ||
                    (cq_word0[11:8] == VEC_OP_DGELU     && !VEC_EN_DGELU)     ||
                    (cq_word0[11:8] == VEC_OP_DSOFTMAX  && !VEC_EN_DSOFTMAX)  ||
                    (cq_word0[11:8] == VEC_OP_DLAYERNORM&& !VEC_EN_DLAYERNORM)||
                    ((cq_word0[11:8] != VEC_OP_RELU)      &&
                     (cq_word0[11:8] != VEC_OP_ADD)       &&
                     (cq_word0[11:8] != VEC_OP_MUL)       &&
                     (cq_word0[11:8] != VEC_OP_GELU)      &&
                     (cq_word0[11:8] != VEC_OP_SOFTMAX)   &&
                     (cq_word0[11:8] != VEC_OP_LAYERNORM) &&
                     (cq_word0[11:8] != VEC_OP_DRELU)     &&
                     (cq_word0[11:8] != VEC_OP_DGELU)     &&
                     (cq_word0[11:8] != VEC_OP_DSOFTMAX)  &&
                     (cq_word0[11:8] != VEC_OP_DLAYERNORM))) begin
                  error_code <= 32'h6;
                end else begin
                  vec_pending <= 1'b1;
                end
              end
            end else begin
              error_code <= 32'h1;
            end
            if (cq_count <= cq_word0_size) begin
              irq_status[IRQ_CQ_EMPTY] <= 1'b1;
            end
            cq_head <= cq_head + (cq_word0_size * 32);
            cq_count <= cq_count - cq_word0_size;
            cq_stage_valid <= 1'b0;
            cq_pending_ext <= 1'b0;
          end
        end
      end

      if (error_code != 0) begin
        status <= STATUS_ERR;
        irq_status[IRQ_ERROR] <= 1'b1;
      end else if (!(mmio_we && mmio_addr == OFF_DOORBELL)) begin
        if ((cq_count != 0) || cq_stage_valid || dma_pending || vec_pending || (gemm_slot_valid != 2'b00)) begin
          status <= STATUS_BUSY;
        end else begin
          status <= STATUS_IDLE;
        end
      end
    end
  end

endmodule
