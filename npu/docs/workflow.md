# NPU Workflow (High-Level)

## Purpose
This document defines the sequential, end-to-end workflow for NPU development and evaluation
inside RTLGen. It complements `npu/setup.md`, which focuses on environment setup.

## Current status
- RTL functional simulation path is implemented (MMIO/CQ/DMA + AXI).
- SRAM address map + AXI router are integrated in RTL sim.
- CACTI-based SRAM PPA estimation is integrated with scaling for >90nm.
- Mapper v0.1 schedule IR + descriptor emission is implemented (`npu/mapper/`).
- Performance simulation (analytical) is implemented (`npu/sim/perf/`).

## 1) Architecture definition
- Create or edit an NPU architecture config (YAML) under `npu/arch/examples/`.
- Validate against `npu/arch/schema.yml` using `npu/arch/validate.py`.

## 2) RTL generation
- Use the NPU generator entrypoint under `npu/rtlgen/` to emit:
  - RTL sources (`verilog/` or `rtl/`)
  - an immutable copy of the architecture config
  - metadata describing top-level IO, clocks, and resets
- Emit generated maps for simulation:
  - `sram_map.vh` (SRAM base/size/alignment)
  - `mmio_map.vh` (MMIO offsets)
- Keep the NVDLA shell stable while iterating on compute and memory subsystems.
 - Optional: emit an AXI-Lite wrapper for MMIO (`top_axi.v`).

## 3) Block-level synthesis (OpenROAD)
- Run OpenROAD block-level PPA for key NPU macros (compute tile, SRAM wrapper, DMA).
- Apply macro-level floorplanning guidance from `npu/synth/floorplan.md`.
- Record results in `runs/designs/` with unique design directories per experiment.

## 4) Mapping and scheduling
- Current mapper entrypoint: `npu/mapper/run.py` consumes a **schedule IR**
  (`npu/mapper/ir.md`) and emits:
  - YAML descriptors (`--out`)
  - binary 32B descriptor stream (`--out-bin`)
- A graph-level mapper (e.g., ONNX → schedule IR) is a separate stage and is
  implemented incrementally.

## 5) Abstracted simulation
- Performance simulation:
  - `npu/sim/perf/run.py` consumes the **binary descriptor stream** and emits a
    JSON timing trace + summary.
  - See `npu/sim/perf/README.md` for bandwidth units and DRAM↔HBM sweep presets.

## 5.1) RTL functional simulation (current)
- Use `npu/sim/rtl/` to validate MMIO, CQ handling, DMA, and AXI memory behavior.
- Drive binary descriptor streams generated by `npu/mapper/run.py --out-bin`.
- SRAM routing is validated via `+sram_test=1` in the benches.
- GEMM/EVENT stub paths are validated via `+event_test=1` in the benches.

## 6) Aggregation and iteration
- Aggregate PPA and simulation results into a consistent, versioned index.
- Use results to revise architecture parameters and re-run the pipeline.
- SRAM metrics are aggregated under `runs/designs/sram/<id>/sram_metrics_summary.json`
  and included in `runs/index.csv`.

## Data management expectations
- Each experiment creates a new design directory under `runs/designs/`.
- Results are append-only (`metrics.csv`) and indexed by `runs/index.csv`.
- Record tool versions, config hashes, and environment details for reproducibility.

## Next steps
- Connect mapping output to the performance simulator once available.
- Add compute/event descriptor coverage in RTL sim.
- Wire sky130hd SRAM macro flow to replace CACTI estimates when available.
