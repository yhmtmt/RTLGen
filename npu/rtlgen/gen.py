#!/usr/bin/env python3
import argparse
import json
import math
import subprocess
import sys
from pathlib import Path


TOP_TEMPLATE = """\
{compute_modules}// Auto-generated by npu/rtlgen/gen.py (v0.1)
module {top_name} (
    input  wire                  clk,
    input  wire                  rst_n,
    input  wire [{mmio_addr_width_minus1}:0] mmio_addr,
    input  wire                  mmio_we,
    input  wire [{data_width_minus1}:0] mmio_wdata,
    output reg  [{data_width_minus1}:0] mmio_rdata,
    output reg                   irq{dma_ports}{cq_mem_ports}{axi_ports}
);

  // Minimal stub: MMIO register block with queue bookkeeping.
  reg [{data_width_minus1}:0] version;
  reg [{data_width_minus1}:0] capabilities;
  reg [{data_width_minus1}:0] status;
  reg [{data_width_minus1}:0] control;
  reg [{data_width_minus1}:0] irq_status;
  reg [{data_width_minus1}:0] irq_enable;
  reg [{data_width_minus1}:0] cq_base_lo;
  reg [{data_width_minus1}:0] cq_base_hi;
  reg [{data_width_minus1}:0] cq_size;
  reg [{data_width_minus1}:0] cq_head;
  reg [{data_width_minus1}:0] cq_tail;
  reg [{data_width_minus1}:0] cq_count;
  reg [255:0] cq_word0;
  reg [7:0]  cq_word0_size;
  reg        cq_pending_ext;
  reg [7:0] last_opcode;
  reg [31:0] last_tag;
  reg [{dma_addr_width_minus1}:0] last_src;
  reg [{dma_addr_width_minus1}:0] last_dst;
  reg [31:0] last_size;
  reg [63:0] last_op_uid;
  reg [{dma_addr_width_minus1}:0] dma_src;
  reg [{dma_addr_width_minus1}:0] dma_dst;
  reg [31:0] dma_size;
  reg        cq_stage_valid;
  reg        dma_pending;
  reg [2:0]  dma_state;
  reg        gemm_pending;
  reg [1:0]  gemm_slot_valid;
  reg [1:0]  gemm_slot_done;
  reg [31:0] gemm_slot_cycles0;
  reg [31:0] gemm_slot_cycles1;
  reg [63:0] gemm_slot_uid0;
  reg [63:0] gemm_slot_uid1;
  reg [{dma_addr_width_minus1}:0] gemm_slot_src0;
  reg [{dma_addr_width_minus1}:0] gemm_slot_src1;
  reg [{dma_addr_width_minus1}:0] gemm_slot_dst0;
  reg [{dma_addr_width_minus1}:0] gemm_slot_dst1;
  reg [31:0] gemm_slot_size0;
  reg [31:0] gemm_slot_size1;
  reg [8:0]  gemm_slot_beats0;
  reg [8:0]  gemm_slot_beats1;
  reg [7:0]  gemm_slot_arlen0;
  reg [7:0]  gemm_slot_arlen1;
  reg        gemm_dma_sel;
  reg        gemm_done_pulse;
  reg [63:0] gemm_done_uid;
{compute_state_regs}
  reg [{axi_data_width_minus1}:0] dma_buf;
  reg [8:0]  dma_beats;
  reg [8:0]  dma_beats_left;
  reg [7:0]  dma_arlen;
  reg [{axi_data_width_minus1}:0] dma_buf_mem [0:255];
  reg [7:0]  dma_rd_idx;
  reg [7:0]  dma_wr_idx;
  reg [{data_width_minus1}:0] error_code;

  localparam STATUS_IDLE = 32'h1;
  localparam STATUS_BUSY = 32'h2;
  localparam STATUS_ERR  = 32'h4;

  localparam integer AXI_BEAT_BYTES = {axi_beat_bytes};

  localparam IRQ_CQ_EMPTY    = 0;
  localparam IRQ_EVENT       = 1;
  localparam IRQ_ERROR       = 2;
  localparam [3:0] VEC_OP_RELU      = 4'h0;
  localparam [3:0] VEC_OP_ADD       = 4'h1;
  localparam [3:0] VEC_OP_MUL       = 4'h2;
  localparam [3:0] VEC_OP_GELU      = 4'h3;
  localparam [3:0] VEC_OP_SOFTMAX   = 4'h4;
  localparam [3:0] VEC_OP_LAYERNORM = 4'h5;
  localparam [3:0] VEC_OP_DRELU     = 4'h6;
  localparam [3:0] VEC_OP_DGELU     = 4'h7;
  localparam [3:0] VEC_OP_DSOFTMAX  = 4'h8;
  localparam [3:0] VEC_OP_DLAYERNORM= 4'h9;
  localparam       VEC_EN_ADD       = {vec_en_add};
  localparam       VEC_EN_MUL       = {vec_en_mul};
  localparam       VEC_EN_RELU      = {vec_en_relu};
  localparam       VEC_EN_GELU      = {vec_en_gelu};
  localparam       VEC_EN_SOFTMAX   = {vec_en_softmax};
  localparam       VEC_EN_LAYERNORM = {vec_en_layernorm};
  localparam       VEC_EN_DRELU     = {vec_en_drelu};
  localparam       VEC_EN_DGELU     = {vec_en_dgelu};
  localparam       VEC_EN_DSOFTMAX  = {vec_en_dsoftmax};
  localparam       VEC_EN_DLAYERNORM= {vec_en_dlayernorm};
  localparam integer GEMM_MAC_LANES = {gemm_mac_lanes};
  localparam integer GEMM_ELEM_BITS = {gemm_elem_bits};
  localparam integer GEMM_FP16_RAW16_PLACEHOLDER = {gemm_fp16_raw16_placeholder};
  localparam integer GEMM_FP16_ACCUM_FP32 = {gemm_fp16_accum_fp32};
  localparam integer VEC_LANES      = {vec_lanes};

  // MMIO offsets (bytes)
  `include "mmio_map.vh"
{compute_instances}

  always @(*) begin
    case (mmio_addr)
      OFF_VERSION:    mmio_rdata = version;
      OFF_CAPS:       mmio_rdata = capabilities;
      OFF_STATUS:     mmio_rdata = status;
      OFF_CONTROL:    mmio_rdata = control;
      OFF_IRQ_STATUS: mmio_rdata = irq_status;
      OFF_IRQ_ENABLE: mmio_rdata = irq_enable;
      OFF_CQ_BASE_LO: mmio_rdata = cq_base_lo;
      OFF_CQ_BASE_HI: mmio_rdata = cq_base_hi;
      OFF_CQ_SIZE:    mmio_rdata = cq_size;
      OFF_CQ_HEAD:    mmio_rdata = cq_head;
      OFF_CQ_TAIL:    mmio_rdata = cq_tail;
      OFF_ERROR_CODE: mmio_rdata = error_code;
      default: mmio_rdata = 0;
    endcase
  end

  always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
      version <= 32'h0001_0001;
      capabilities <= 32'h0000_0133; // DMA_COPY/STRIDED/GATHER/SCATTER + GEMM/VEC/SOFTMAX + EVENT_IRQ
      status <= STATUS_IDLE;
      control <= 0;
      irq_status <= 0;
      irq_enable <= 0;
      cq_base_lo <= 0;
      cq_base_hi <= 0;
      cq_size <= 0;
      cq_head <= 0;
      cq_tail <= 0;
      cq_count <= 0;
      cq_word0 <= 0;
      cq_word0_size <= 0;
      cq_pending_ext <= 0;
      error_code <= 0;
      irq <= 0;
      last_opcode <= 0;
      last_tag <= 0;
      last_src <= 0;
      last_dst <= 0;
      last_size <= 0;
      last_op_uid <= 0;
      dma_src <= 0;
      dma_dst <= 0;
      dma_size <= 0;
      cq_stage_valid <= 0;
      dma_pending <= 0;
      dma_state <= 0;
      gemm_pending <= 0;
      gemm_slot_valid <= 0;
      gemm_slot_done <= 0;
      gemm_slot_cycles0 <= 0;
      gemm_slot_cycles1 <= 0;
      gemm_slot_uid0 <= 0;
      gemm_slot_uid1 <= 0;
      gemm_slot_src0 <= 0;
      gemm_slot_src1 <= 0;
      gemm_slot_dst0 <= 0;
      gemm_slot_dst1 <= 0;
      gemm_slot_size0 <= 0;
      gemm_slot_size1 <= 0;
      gemm_slot_beats0 <= 0;
      gemm_slot_beats1 <= 0;
      gemm_slot_arlen0 <= 0;
      gemm_slot_arlen1 <= 0;
      gemm_dma_sel <= 0;
      gemm_done_pulse <= 0;
      gemm_done_uid <= 0;
{compute_reset}
      dma_buf <= 0;
      dma_beats <= 0;
      dma_beats_left <= 0;
      dma_arlen <= 0;
      dma_rd_idx <= 0;
      dma_wr_idx <= 0;
{dma_reset}
{axi_reset}
    end else begin
      // Default: clear level IRQ unless status bit set
      irq <= |(irq_status & irq_enable);
{dma_handshake}
{gemm_update}
{axi_defaults}
{axi_fsm}

      if (mmio_we) begin
        case (mmio_addr)
          OFF_CONTROL: control <= mmio_wdata;
          OFF_IRQ_STATUS: irq_status <= irq_status & ~mmio_wdata; // W1C
          OFF_IRQ_ENABLE: irq_enable <= mmio_wdata;
          OFF_CQ_BASE_LO: cq_base_lo <= mmio_wdata;
          OFF_CQ_BASE_HI: cq_base_hi <= mmio_wdata;
          OFF_CQ_SIZE:    cq_size <= mmio_wdata;
          OFF_CQ_TAIL:    cq_tail <= mmio_wdata;
          OFF_DOORBELL: begin
            // Minimal behavior: consume all queued descriptors.
            cq_count <= ((cq_tail - cq_head) >> 5);
            if (((cq_tail - cq_head) >> 5) == 0) begin
              status <= STATUS_IDLE;
              irq_status[IRQ_CQ_EMPTY] <= 1'b1;
            end else begin
              status <= STATUS_BUSY;
            end
{dma_kick}
          end
          default: begin end
        endcase
      end

{cq_block}

      if (error_code != 0) begin
        status <= STATUS_ERR;
        irq_status[IRQ_ERROR] <= 1'b1;
      end else if (!(mmio_we && mmio_addr == OFF_DOORBELL)) begin
        if ((cq_count != 0) || cq_stage_valid || dma_pending || vec_pending || (gemm_slot_valid != 2'b00)) begin
          status <= STATUS_BUSY;
        end else begin
          status <= STATUS_IDLE;
        end
      end
    end
  end

endmodule
"""

SRAM_1R1W_MODEL = """\
// Simple 1R1W SRAM model (behavioral, for simulation)
module sram_1r1w #(
    parameter ADDR_WIDTH = 10,
    parameter DATA_WIDTH = 32,
    parameter READ_LATENCY = 1,
    parameter BYTE_ENABLE = 1
) (
    input  wire                  clk,
    input  wire                  we,
    input  wire [ADDR_WIDTH-1:0] waddr,
    input  wire [DATA_WIDTH-1:0] wdata,
    input  wire [(DATA_WIDTH/8)-1:0] wstrb,
    input  wire                  re,
    input  wire [ADDR_WIDTH-1:0] raddr,
    output reg  [DATA_WIDTH-1:0] rdata
);
  reg [DATA_WIDTH-1:0] mem [0:(1<<ADDR_WIDTH)-1];
  reg [DATA_WIDTH-1:0] rdata_pipe [0:READ_LATENCY-1];
  integer i;

  always @(posedge clk) begin
    if (we) begin
      if (BYTE_ENABLE) begin
        for (i = 0; i < (DATA_WIDTH/8); i = i + 1) begin
          if (wstrb[i])
            mem[waddr][(i*8)+7 -: 8] <= wdata[(i*8)+7 -: 8];
        end
      end else begin
        mem[waddr] <= wdata;
      end
    end
    if (re) begin
      rdata_pipe[0] <= mem[raddr];
      for (i = 1; i < READ_LATENCY; i = i + 1)
        rdata_pipe[i] <= rdata_pipe[i-1];
      rdata <= rdata_pipe[READ_LATENCY-1];
    end
  end
endmodule
"""

SRAM_1R1W_WRAPPER = """\
// Auto-generated SRAM instance wrapper
module {inst_name} (
    input  wire                  clk,
    input  wire                  we,
    input  wire [{addr_width_minus1}:0] waddr,
    input  wire [{data_width_minus1}:0] wdata,
    input  wire [{strb_width_minus1}:0] wstrb,
    input  wire                  re,
    input  wire [{addr_width_minus1}:0] raddr,
    output wire [{data_width_minus1}:0] rdata
);
  sram_1r1w #(
    .ADDR_WIDTH({addr_width}),
    .DATA_WIDTH({data_width}),
    .READ_LATENCY({read_latency}),
    .BYTE_ENABLE({byte_enable})
  ) u_mem (
    .clk(clk),
    .we(we),
    .waddr(waddr),
    .wdata(wdata),
    .wstrb(wstrb),
    .re(re),
    .raddr(raddr),
    .rdata(rdata)
  );
endmodule
"""

GEMM_MAC_INT8 = """\
module gemm_mac_int8 #(
    parameter integer LANES = 8,
    parameter integer ACC_WIDTH = 32
) (
    input  wire [LANES*8-1:0] a_vec,
    input  wire [LANES*8-1:0] b_vec,
    output reg  signed [ACC_WIDTH-1:0] acc_out
);
  integer i;
  reg signed [ACC_WIDTH-1:0] sum;
  reg signed [7:0] a_i;
  reg signed [7:0] b_i;

  always @(*) begin
    sum = 0;
    for (i = 0; i < LANES; i = i + 1) begin
      a_i = a_vec[(i*8) +: 8];
      b_i = b_vec[(i*8) +: 8];
      sum = sum + (a_i * b_i);
    end
    acc_out = sum;
  end
endmodule
"""

GEMM_MAC_INT16 = """\
module gemm_mac_int16 #(
    parameter integer LANES = 4,
    parameter integer ACC_WIDTH = 32
) (
    input  wire [LANES*16-1:0] a_vec,
    input  wire [LANES*16-1:0] b_vec,
    output reg  signed [ACC_WIDTH-1:0] acc_out
);
  integer i;
  reg signed [ACC_WIDTH-1:0] sum;
  reg signed [15:0] a_i;
  reg signed [15:0] b_i;

  always @(*) begin
    sum = 0;
    for (i = 0; i < LANES; i = i + 1) begin
      a_i = a_vec[(i*16) +: 16];
      b_i = b_vec[(i*16) +: 16];
      sum = sum + (a_i * b_i);
    end
    acc_out = sum;
  end
endmodule
"""

GEMM_MAC_FP16 = """\
module gemm_mac_fp16 #(
    parameter integer LANES = 4,
    parameter integer ACC_WIDTH = 32
) (
    input  wire [LANES*16-1:0] a_vec,
    input  wire [LANES*16-1:0] b_vec,
    output reg  signed [ACC_WIDTH-1:0] acc_out
);
  integer i;
  reg signed [ACC_WIDTH-1:0] sum;
  reg signed [15:0] a_i;
  reg signed [15:0] b_i;

  // Phase-3 placeholder: treat fp16 lanes as raw signed-16 values.
  // Swap this block with true IEEE-754 half MAC when fp16 datapath is integrated.
  always @(*) begin
    sum = 0;
    for (i = 0; i < LANES; i = i + 1) begin
      a_i = a_vec[(i*16) +: 16];
      b_i = b_vec[(i*16) +: 16];
      sum = sum + (a_i * b_i);
    end
    acc_out = sum;
  end
endmodule
"""

AXI_LITE_BRIDGE = """\
// Simple AXI-Lite to MMIO bridge (single-beat)
module axi_lite_mmio_bridge (
    input  wire                  clk,
    input  wire                  rst_n,
    // AXI-Lite slave interface
    input  wire [31:0]           s_axi_awaddr,
    input  wire                  s_axi_awvalid,
    output reg                   s_axi_awready,
    input  wire [{data_width_minus1}:0] s_axi_wdata,
    input  wire [(32/8)-1:0]    s_axi_wstrb,
    input  wire                  s_axi_wvalid,
    output reg                   s_axi_wready,
    output reg  [1:0]            s_axi_bresp,
    output reg                   s_axi_bvalid,
    input  wire                  s_axi_bready,
    input  wire [31:0]           s_axi_araddr,
    input  wire                  s_axi_arvalid,
    output reg                   s_axi_arready,
    output reg  [{data_width_minus1}:0] s_axi_rdata,
    output reg  [1:0]            s_axi_rresp,
    output reg                   s_axi_rvalid,
    input  wire                  s_axi_rready,
    // MMIO side
    output reg  [{mmio_addr_width_minus1}:0] mmio_addr,
    output reg                   mmio_we,
    output reg  [{data_width_minus1}:0] mmio_wdata,
    input  wire [{data_width_minus1}:0] mmio_rdata
);

  reg read_pending;

  always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
      s_axi_awready <= 1'b0;
      s_axi_wready <= 1'b0;
      s_axi_bvalid <= 1'b0;
      s_axi_bresp <= 2'b00;
      s_axi_arready <= 1'b0;
      s_axi_rvalid <= 1'b0;
      s_axi_rresp <= 2'b00;
      s_axi_rdata <= 0;
      mmio_addr <= 0;
      mmio_we <= 1'b0;
      mmio_wdata <= 0;
      read_pending <= 1'b0;
    end else begin
      s_axi_awready <= s_axi_awvalid;
      s_axi_wready <= s_axi_wvalid;
      s_axi_arready <= (!read_pending && !s_axi_rvalid);
      mmio_we <= 1'b0;

      if (s_axi_awvalid && s_axi_wvalid) begin
        mmio_addr <= s_axi_awaddr[{mmio_addr_width_minus1}:0];
        mmio_wdata <= s_axi_wdata;
        mmio_we <= 1'b1;
        s_axi_bvalid <= 1'b1;
        s_axi_bresp <= 2'b00;
      end

      if (s_axi_bvalid && s_axi_bready)
        s_axi_bvalid <= 1'b0;

      if (s_axi_arvalid && s_axi_arready) begin
        mmio_addr <= s_axi_araddr[{mmio_addr_width_minus1}:0];
        read_pending <= 1'b1;
      end

      if (read_pending && !s_axi_rvalid) begin
        s_axi_rdata <= mmio_rdata;
        s_axi_rvalid <= 1'b1;
        s_axi_rresp <= 2'b00;
        read_pending <= 1'b0;
      end

      if (s_axi_rvalid && s_axi_rready) begin
        s_axi_rvalid <= 1'b0;
      end
    end
  end

endmodule
"""

AXI_LITE_WRAPPER = """\
// Auto-generated AXI-Lite wrapper (v0.1)
module {top_name}_axi (
    input  wire                  clk,
    input  wire                  rst_n,
    // AXI-Lite slave
    input  wire [31:0]           s_axi_awaddr,
    input  wire                  s_axi_awvalid,
    output wire                  s_axi_awready,
    input  wire [31:0]           s_axi_wdata,
    input  wire [3:0]            s_axi_wstrb,
    input  wire                  s_axi_wvalid,
    output wire                  s_axi_wready,
    output wire [1:0]            s_axi_bresp,
    output wire                  s_axi_bvalid,
    input  wire                  s_axi_bready,
    input  wire [31:0]           s_axi_araddr,
    input  wire                  s_axi_arvalid,
    output wire                  s_axi_arready,
    output wire [31:0]           s_axi_rdata,
    output wire [1:0]            s_axi_rresp,
    output wire                  s_axi_rvalid,
    input  wire                  s_axi_rready,
    // Interrupt
    output wire                  irq,
    // DMA stub ports
    output wire                  dma_req_valid,
    output wire [{dma_addr_width_minus1}:0] dma_req_src,
    output wire [{dma_addr_width_minus1}:0] dma_req_dst,
    output wire [31:0]           dma_req_bytes,
    input  wire                  dma_req_ready,
    input  wire                  dma_resp_done,
    // CQ memory port
    output wire [{dma_addr_width_minus1}:0] cq_mem_addr,
    input  wire [255:0]          cq_mem_rdata,
    // AXI memory master
    output wire                  m_axi_awvalid,
    input  wire                  m_axi_awready,
    output wire [{axi_addr_width_minus1}:0] m_axi_awaddr,
    output wire [7:0]            m_axi_awlen,
    output wire [2:0]            m_axi_awsize,
    output wire                  m_axi_wvalid,
    input  wire                  m_axi_wready,
    output wire [{axi_data_width_minus1}:0] m_axi_wdata,
    output wire [{axi_strb_width_minus1}:0] m_axi_wstrb,
    output wire                  m_axi_wlast,
    input  wire                  m_axi_bvalid,
    output wire                  m_axi_bready,
    output wire                  m_axi_arvalid,
    input  wire                  m_axi_arready,
    output wire [{axi_addr_width_minus1}:0] m_axi_araddr,
    output wire [7:0]            m_axi_arlen,
    output wire [2:0]            m_axi_arsize,
    input  wire                  m_axi_rvalid,
    output wire                  m_axi_rready,
    input  wire [{axi_data_width_minus1}:0] m_axi_rdata,
    input  wire                  m_axi_rlast
);
  wire [{mmio_addr_width_minus1}:0] mmio_addr;
  wire        mmio_we;
  wire [{data_width_minus1}:0] mmio_wdata;
  wire [{data_width_minus1}:0] mmio_rdata;

  axi_lite_mmio_bridge u_bridge (
    .clk(clk),
    .rst_n(rst_n),
    .s_axi_awaddr(s_axi_awaddr),
    .s_axi_awvalid(s_axi_awvalid),
    .s_axi_awready(s_axi_awready),
    .s_axi_wdata(s_axi_wdata),
    .s_axi_wstrb(s_axi_wstrb),
    .s_axi_wvalid(s_axi_wvalid),
    .s_axi_wready(s_axi_wready),
    .s_axi_bresp(s_axi_bresp),
    .s_axi_bvalid(s_axi_bvalid),
    .s_axi_bready(s_axi_bready),
    .s_axi_araddr(s_axi_araddr),
    .s_axi_arvalid(s_axi_arvalid),
    .s_axi_arready(s_axi_arready),
    .s_axi_rdata(s_axi_rdata),
    .s_axi_rresp(s_axi_rresp),
    .s_axi_rvalid(s_axi_rvalid),
    .s_axi_rready(s_axi_rready),
    .mmio_addr(mmio_addr),
    .mmio_we(mmio_we),
    .mmio_wdata(mmio_wdata),
    .mmio_rdata(mmio_rdata)
  );

  {top_name} u_top (
    .clk(clk),
    .rst_n(rst_n),
    .mmio_addr(mmio_addr),
    .mmio_we(mmio_we),
    .mmio_wdata(mmio_wdata),
    .mmio_rdata(mmio_rdata),
    .irq(irq),
    .dma_req_valid(dma_req_valid),
    .dma_req_src(dma_req_src),
    .dma_req_dst(dma_req_dst),
    .dma_req_bytes(dma_req_bytes),
    .dma_req_ready(dma_req_ready),
    .dma_resp_done(dma_resp_done),
    .cq_mem_addr(cq_mem_addr),
    .cq_mem_rdata(cq_mem_rdata),
    .m_axi_awvalid(m_axi_awvalid),
    .m_axi_awready(m_axi_awready),
    .m_axi_awaddr(m_axi_awaddr),
    .m_axi_awlen(m_axi_awlen),
    .m_axi_awsize(m_axi_awsize),
    .m_axi_wvalid(m_axi_wvalid),
    .m_axi_wready(m_axi_wready),
    .m_axi_wdata(m_axi_wdata),
    .m_axi_wstrb(m_axi_wstrb),
    .m_axi_wlast(m_axi_wlast),
    .m_axi_bvalid(m_axi_bvalid),
    .m_axi_bready(m_axi_bready),
    .m_axi_arvalid(m_axi_arvalid),
    .m_axi_arready(m_axi_arready),
    .m_axi_araddr(m_axi_araddr),
    .m_axi_arlen(m_axi_arlen),
    .m_axi_arsize(m_axi_arsize),
    .m_axi_rvalid(m_axi_rvalid),
    .m_axi_rready(m_axi_rready),
    .m_axi_rdata(m_axi_rdata),
    .m_axi_rlast(m_axi_rlast)
  );
endmodule
"""


def die(msg: str) -> None:
    print(f"rtlgen: {msg}", file=sys.stderr)
    sys.exit(1)


def load_config(path: str) -> dict:
    with open(path, "r", encoding="utf-8") as f:
        cfg = json.load(f)
    if cfg.get("version") != "0.1":
        die("config version must be 0.1")
    return cfg


def resolve_rtlgen_bin_path(binary_path: str) -> Path:
    rtlgen_bin_path = Path(binary_path)
    if not rtlgen_bin_path.is_absolute():
        rtlgen_bin_path = Path.cwd() / rtlgen_bin_path
    if not rtlgen_bin_path.exists():
        die(
            f"RTLGen binary not found: {rtlgen_bin_path}. "
            "Build C++ rtlgen first or update binary_path."
        )
    return rtlgen_bin_path


def generate_cpp_mac_module(gemm_cfg: dict, out_path: Path) -> tuple[str, str]:
    cpp_cfg = gemm_cfg.get("rtlgen_cpp", {})
    if cpp_cfg is None:
        cpp_cfg = {}
    if not isinstance(cpp_cfg, dict):
        die("compute.gemm.rtlgen_cpp must be an object when provided")

    rtlgen_bin = str(cpp_cfg.get("binary_path", "build/rtlgen"))
    rtlgen_bin_path = resolve_rtlgen_bin_path(rtlgen_bin)

    module_name = str(cpp_cfg.get("module_name", "gemm_mac_int8_pp"))
    mac_cfg = {
        "version": "1.1",
        "operands": [
            {
                "name": "int8",
                "dimensions": 1,
                "bit_width": 8,
                "signed": True,
            }
        ],
        "operations": [
            {
                "type": "mac",
                "module_name": module_name,
                "operand": "int8",
                "options": {
                    "ppg_algorithm": str(cpp_cfg.get("ppg_algorithm", "Booth4")),
                    "compressor_structure": str(cpp_cfg.get("compressor_structure", "AdderTree")),
                    "compressor_library": str(cpp_cfg.get("compressor_library", "fa_ha")),
                    "compressor_assignment": str(cpp_cfg.get("compressor_assignment", "legacy_fa_ha")),
                    "cpa_structure": str(cpp_cfg.get("cpa_structure", "BrentKung")),
                    "accumulation_mode": "pp_row_feedback",
                    "pipeline_depth": 1,
                },
            }
        ],
    }

    gen_dir = out_path / ".rtlgen_cpp_mac"
    gen_dir.mkdir(parents=True, exist_ok=True)
    cfg_path = (gen_dir / "mac_config.json").resolve()
    cfg_path.write_text(json.dumps(mac_cfg, indent=2) + "\n", encoding="utf-8")

    try:
        run = subprocess.run(
            [str(rtlgen_bin_path), str(cfg_path)],
            cwd=str(gen_dir),
            check=True,
            capture_output=True,
            text=True,
        )
    except subprocess.CalledProcessError as exc:
        stderr_text = exc.stderr.strip() if exc.stderr else ""
        stdout_text = exc.stdout.strip() if exc.stdout else ""
        details = stderr_text or stdout_text or "no stdout/stderr"
        die(f"C++ RTLGen mac generation failed: {details}")

    module_file = gen_dir / f"{module_name}.v"
    cpa_file = gen_dir / "MG_CPA.v"
    if not module_file.exists():
        die(f"C++ RTLGen mac output missing: {module_file}")
    if not cpa_file.exists():
        die(f"C++ RTLGen mac dependency missing: {cpa_file}")

    module_text = module_file.read_text(encoding="utf-8")
    cpa_text = cpa_file.read_text(encoding="utf-8")
    return module_name, (module_text + "\n\n" + cpa_text + "\n")


def generate_cpp_vec_activation_modules(vec_cfg: dict, out_path: Path) -> tuple[str, dict[str, str]]:
    cpp_cfg = vec_cfg.get("rtlgen_cpp", {})
    if cpp_cfg is None:
        cpp_cfg = {}
    if not isinstance(cpp_cfg, dict):
        die("compute.vec.rtlgen_cpp must be an object when provided")

    rtlgen_bin = str(cpp_cfg.get("binary_path", "build/rtlgen"))
    rtlgen_bin_path = resolve_rtlgen_bin_path(rtlgen_bin)

    ops_raw = vec_cfg.get("ops", [])
    if ops_raw is None:
        ops_raw = []
    if not isinstance(ops_raw, list):
        die("compute.vec.ops must be a list when provided")
    vec_ops = [str(op).lower() for op in ops_raw]

    # C++ activation emitter supports these function names.
    fn_map = {
        "relu": "relu",
        "gelu": "gelu",
        "softmax": "softmax",
        "layernorm": "layernorm",
        "drelu": "drelu",
        "dgelu": "dgelu",
        "dsoftmax": "dsoftmax",
        "dlayernorm": "dlayernorm",
    }
    pending_ops = {
        "rmsnorm",
        "drmsnorm",
    }

    module_prefix = str(cpp_cfg.get("module_prefix", "vec_act"))
    modules: list[str] = []
    module_names: dict[str, str] = {}
    gen_dir = out_path / ".rtlgen_cpp_vec"
    gen_dir.mkdir(parents=True, exist_ok=True)

    for op in vec_ops:
        if op not in fn_map:
            continue
        fn = fn_map[op]
        module_name = f"{module_prefix}_{op}_int8"
        act_cfg = {
            "version": "1.1",
            "operands": [
                {
                    "name": "vec",
                    "dimensions": 1,
                    "bit_width": 8,
                    "signed": True,
                }
            ],
            "operations": [
                {
                    "type": "activation",
                    "module_name": module_name,
                    "operand": "vec",
                    "options": {"function": fn},
                }
            ],
        }
        cfg_path = (gen_dir / f"{module_name}.json").resolve()
        cfg_path.write_text(json.dumps(act_cfg, indent=2) + "\n", encoding="utf-8")
        try:
            subprocess.run(
                [str(rtlgen_bin_path), str(cfg_path)],
                cwd=str(gen_dir),
                check=True,
                capture_output=True,
                text=True,
            )
        except subprocess.CalledProcessError as exc:
            stderr_text = exc.stderr.strip() if exc.stderr else ""
            stdout_text = exc.stdout.strip() if exc.stdout else ""
            details = stderr_text or stdout_text or "no stdout/stderr"
            die(f"C++ RTLGen vec activation generation failed for {op}: {details}")

        module_file = gen_dir / f"{module_name}.v"
        if not module_file.exists():
            die(f"C++ RTLGen activation output missing: {module_file}")
        modules.append(module_file.read_text(encoding="utf-8"))
        module_names[op] = module_name

    requested_pending = [op for op in vec_ops if op in pending_ops]
    if requested_pending:
        print(
            "rtlgen: note: compute.vec requested future ops "
            f"{requested_pending}; C++ generator integration is pending for these functions."
        )

    if not modules:
        return "", {}
    return "\n\n".join(modules) + "\n\n", module_names


def write_outputs(cfg: dict, out_dir: str) -> None:
    out_path = Path(out_dir)
    out_path.mkdir(parents=True, exist_ok=True)

    top_name = cfg["top_name"]
    mmio_addr_width = int(cfg["mmio_addr_width"])
    data_width = int(cfg["data_width"])
    dma_addr_width = int(cfg.get("dma_addr_width", 64))
    dma_data_width = int(cfg.get("dma_data_width", 256))
    axi_addr_width = int(cfg.get("axi_addr_width", 64))
    axi_data_width = int(cfg.get("axi_data_width", 256))
    axi_id_width = int(cfg.get("axi_id_width", 4))

    if axi_data_width % 8 != 0:
        die("axi_data_width must be a multiple of 8")
    axi_strb_width = axi_data_width // 8
    if (axi_strb_width & (axi_strb_width - 1)) != 0:
        die("axi_data_width must be a power-of-two number of bytes")
    axi_size = int(math.log2(axi_strb_width))
    if (1 << axi_size) != axi_strb_width:
        die("axi_data_width must be a power-of-two number of bytes")

    if axi_size == 0:
        dma_beats_expr = "cq_mem_rdata[223:192]"
        dma_arlen_expr = "cq_mem_rdata[223:192] - 1"
    else:
        hi = 223
        lo = 192 + axi_size
        rem_hi = lo - 1
        dma_beats_expr = f"(cq_mem_rdata[{hi}:{lo}] + (|cq_mem_rdata[{rem_hi}:192]))"
        dma_arlen_expr = f"(cq_mem_rdata[{hi}:{lo}] + (|cq_mem_rdata[{rem_hi}:192])) - 1"

    dma_addr_width_minus1 = dma_addr_width - 1
    axi_addr_width_minus1 = axi_addr_width - 1
    axi_data_width_minus1 = axi_data_width - 1
    axi_strb_width_minus1 = axi_strb_width - 1

    compute_cfg = cfg.get("compute", {})
    if compute_cfg is None:
        compute_cfg = {}
    if not isinstance(compute_cfg, dict):
        die("compute must be an object when provided")
    gemm_cfg = compute_cfg.get("gemm", {})
    if gemm_cfg is None:
        gemm_cfg = {}
    if not isinstance(gemm_cfg, dict):
        die("compute.gemm must be an object when provided")
    vec_cfg = compute_cfg.get("vec", {})
    if vec_cfg is None:
        vec_cfg = {}
    if not isinstance(vec_cfg, dict):
        die("compute.vec must be an object when provided")

    compute_enabled = bool(compute_cfg.get("enabled", False))
    gemm_mac_type = str(gemm_cfg.get("mac_type", "int8")).lower()
    gemm_mac_source_raw = gemm_cfg.get("mac_source")
    if gemm_mac_source_raw is None:
        if gemm_mac_type == "int16":
            gemm_mac_source = "builtin_int16_dot"
        elif gemm_mac_type == "fp16":
            gemm_mac_source = "builtin_fp16_dot"
        else:
            gemm_mac_source = "builtin_int8_dot"
    else:
        gemm_mac_source = str(gemm_mac_source_raw).lower()
    gemm_mac_lanes = int(gemm_cfg.get("lanes", 8))
    gemm_accum_width = int(gemm_cfg.get("accum_width", 32))
    gemm_pipeline = int(gemm_cfg.get("pipeline", 1))
    gemm_fp16_cfg = gemm_cfg.get("fp16", {})
    if gemm_fp16_cfg is None:
        gemm_fp16_cfg = {}
    if not isinstance(gemm_fp16_cfg, dict):
        die("compute.gemm.fp16 must be an object when provided")
    gemm_fp16_semantics = str(gemm_fp16_cfg.get("semantics", "raw16_placeholder")).lower()
    gemm_fp16_accumulation = str(gemm_fp16_cfg.get("accumulation", "int32")).lower()
    gemm_fp16_rounding = str(gemm_fp16_cfg.get("rounding", "rne")).lower()
    gemm_fp16_subnormals = str(gemm_fp16_cfg.get("subnormals", "preserve")).lower()
    vec_activation_source = str(vec_cfg.get("activation_source", "builtin")).lower()
    vec_lanes = int(vec_cfg.get("lanes", 8))
    vec_ops_raw = vec_cfg.get("ops", [])
    if vec_ops_raw is None:
        vec_ops_raw = []
    if not isinstance(vec_ops_raw, list):
        die("compute.vec.ops must be a list when provided")
    vec_ops = [str(op).lower() for op in vec_ops_raw]
    if not vec_ops:
        vec_ops = ["add", "mul", "relu"]
    supported_vec_ops = {
        "add",
        "mul",
        "relu",
        "gelu",
        "softmax",
        "layernorm",
        "drelu",
        "dgelu",
        "dsoftmax",
        "dlayernorm",
    }
    unknown_vec_ops = sorted({op for op in vec_ops if op not in supported_vec_ops})
    if unknown_vec_ops:
        die(f"unsupported compute.vec.ops values: {unknown_vec_ops}")
    vec_en_add = 1 if "add" in vec_ops else 0
    vec_en_mul = 1 if "mul" in vec_ops else 0
    vec_en_relu = 1 if "relu" in vec_ops else 0
    vec_en_gelu = 1 if "gelu" in vec_ops else 0
    vec_en_softmax = 1 if "softmax" in vec_ops else 0
    vec_en_layernorm = 1 if "layernorm" in vec_ops else 0
    vec_en_drelu = 1 if "drelu" in vec_ops else 0
    vec_en_dgelu = 1 if "dgelu" in vec_ops else 0
    vec_en_dsoftmax = 1 if "dsoftmax" in vec_ops else 0
    vec_en_dlayernorm = 1 if "dlayernorm" in vec_ops else 0

    if gemm_pipeline < 1:
        die("compute.gemm.pipeline must be >= 1")

    if compute_enabled and gemm_mac_type not in ("int8", "int16", "fp16"):
        die("compute.gemm.mac_type must be one of: int8, int16, fp16")
    if gemm_mac_type in ("int16", "fp16"):
        if gemm_mac_lanes < 1 or gemm_mac_lanes > 4:
            die("compute.gemm.lanes must be in [1, 4] when compute.gemm.mac_type is int16/fp16")
    else:
        if gemm_mac_lanes < 1 or gemm_mac_lanes > 8:
            die("compute.gemm.lanes must be in [1, 8] when compute.gemm.mac_type=int8")
    if gemm_accum_width < 16 or gemm_accum_width > 64:
        die("compute.gemm.accum_width must be in [16, 64]")
    if gemm_fp16_semantics not in ("raw16_placeholder", "ieee_half"):
        die("compute.gemm.fp16.semantics must be one of: raw16_placeholder, ieee_half")
    if gemm_fp16_accumulation not in ("int32", "fp32"):
        die("compute.gemm.fp16.accumulation must be one of: int32, fp32")
    if gemm_fp16_rounding not in ("rne",):
        die("compute.gemm.fp16.rounding must be: rne")
    if gemm_fp16_subnormals not in ("preserve", "flush"):
        die("compute.gemm.fp16.subnormals must be one of: preserve, flush")
    if gemm_mac_type == "int16":
        if gemm_mac_source not in ("builtin", "builtin_int16_dot"):
            die("compute.gemm.mac_source must be one of: builtin, builtin_int16_dot for mac_type=int16")
    elif gemm_mac_type == "fp16":
        if gemm_mac_source not in ("builtin", "builtin_fp16_dot"):
            die("compute.gemm.mac_source must be one of: builtin, builtin_fp16_dot for mac_type=fp16")
        if gemm_fp16_semantics == "ieee_half":
            die(
                "compute.gemm.fp16.semantics=ieee_half is planned but not implemented yet; "
                "use raw16_placeholder"
            )
        if gemm_fp16_accumulation != "int32":
            die("compute.gemm.fp16.accumulation must be int32 when semantics=raw16_placeholder")
        if gemm_fp16_rounding != "rne":
            die("compute.gemm.fp16.rounding must be rne for current fp16 bring-up path")
        if gemm_fp16_subnormals != "preserve":
            die("compute.gemm.fp16.subnormals must be preserve for current fp16 bring-up path")
    else:
        if gemm_mac_source not in ("builtin", "builtin_int8_dot", "rtlgen_cpp"):
            die("compute.gemm.mac_source must be one of: builtin_int8_dot, builtin, rtlgen_cpp")
    if compute_enabled and gemm_mac_source == "rtlgen_cpp":
        if gemm_mac_type != "int8":
            die("compute.gemm.mac_type must be int8 when compute.gemm.mac_source=rtlgen_cpp")
        if gemm_mac_lanes != 1:
            die("compute.gemm.lanes must be 1 when compute.gemm.mac_source=rtlgen_cpp")
        if gemm_accum_width != 16:
            die("compute.gemm.accum_width must be 16 when compute.gemm.mac_source=rtlgen_cpp")
    if vec_activation_source not in ("builtin", "rtlgen_cpp"):
        die("compute.vec.activation_source must be one of: builtin, rtlgen_cpp")
    if vec_lanes < 1 or vec_lanes > 8:
        die("compute.vec.lanes must be in [1, 8]")

    gemm_elem_bits = 16 if gemm_mac_type in ("int16", "fp16") else 8
    gemm_fp16_raw16_placeholder = 1 if (gemm_mac_type == "fp16" and gemm_fp16_semantics == "raw16_placeholder") else 0
    gemm_fp16_accum_fp32 = 1 if (gemm_mac_type == "fp16" and gemm_fp16_accumulation == "fp32") else 0
    gemm_mac_vec_width = gemm_mac_lanes * gemm_elem_bits
    gemm_mac_vec_width_minus1 = gemm_mac_vec_width - 1
    gemm_accum_width_minus1 = gemm_accum_width - 1
    gemm_a_hi = 64 + gemm_mac_vec_width - 1
    gemm_b_hi = 128 + gemm_mac_vec_width - 1
    vec_data_width = vec_lanes * 8
    vec_data_width_minus1 = vec_data_width - 1
    vec_a_hi = 64 + vec_data_width - 1
    vec_b_hi = 128 + vec_data_width - 1

    use_cpp_mac = compute_enabled and (gemm_mac_source == "rtlgen_cpp")
    if use_cpp_mac:
        cpp_module_name, cpp_module_text = generate_cpp_mac_module(gemm_cfg, out_path)
        compute_modules = cpp_module_text + "\n"
    else:
        cpp_module_name = ""
        compute_modules = GEMM_MAC_INT8 + "\n\n" + GEMM_MAC_INT16 + "\n\n" + GEMM_MAC_FP16 + "\n\n"

    vec_cpp_modules: dict[str, str] = {}
    if compute_enabled and vec_activation_source == "rtlgen_cpp":
        vec_module_text, vec_cpp_modules = generate_cpp_vec_activation_modules(vec_cfg, out_path)
        compute_modules = compute_modules + vec_module_text
    vec_cpp_relu_module = vec_cpp_modules.get("relu", "")
    vec_cpp_gelu_module = vec_cpp_modules.get("gelu", "")
    vec_cpp_softmax_module = vec_cpp_modules.get("softmax", "")
    vec_cpp_layernorm_module = vec_cpp_modules.get("layernorm", "")
    vec_cpp_drelu_module = vec_cpp_modules.get("drelu", "")
    vec_cpp_dgelu_module = vec_cpp_modules.get("dgelu", "")
    vec_cpp_dsoftmax_module = vec_cpp_modules.get("dsoftmax", "")
    vec_cpp_dlayernorm_module = vec_cpp_modules.get("dlayernorm", "")
    use_cpp_relu = bool(vec_cpp_relu_module)
    use_cpp_gelu = bool(vec_cpp_gelu_module)
    use_cpp_softmax = bool(vec_cpp_softmax_module)
    use_cpp_layernorm = bool(vec_cpp_layernorm_module)
    use_cpp_drelu = bool(vec_cpp_drelu_module)
    use_cpp_dgelu = bool(vec_cpp_dgelu_module)
    use_cpp_dsoftmax = bool(vec_cpp_dsoftmax_module)
    use_cpp_dlayernorm = bool(vec_cpp_dlayernorm_module)

    compute_state_regs = f"""  reg [{gemm_mac_vec_width_minus1}:0] gemm_mac_a_vec0;
  reg [{gemm_mac_vec_width_minus1}:0] gemm_mac_b_vec0;
  reg [{gemm_mac_vec_width_minus1}:0] gemm_mac_a_vec1;
  reg [{gemm_mac_vec_width_minus1}:0] gemm_mac_b_vec1;
  reg signed [{gemm_accum_width_minus1}:0] gemm_slot_accum0;
  reg signed [{gemm_accum_width_minus1}:0] gemm_slot_accum1;
  reg [{vec_data_width_minus1}:0] vec_in0;
  reg [{vec_data_width_minus1}:0] vec_in1;
  reg [{vec_data_width_minus1}:0] vec_last_result;
  reg [3:0] vec_op_sel;
  reg vec_pending;
  reg vec_done_pulse;"""

    if use_cpp_mac:
        gemm_compute_instances = f"""
  wire signed [15:0] gemm_mac_next0;
  wire signed [15:0] gemm_mac_next1;

  {cpp_module_name} u_gemm_mac0 (
    .multiplicand(gemm_mac_a_vec0[7:0]),
    .multiplier(gemm_mac_b_vec0[7:0]),
    .accumulator(gemm_slot_accum0[15:0]),
    .result(gemm_mac_next0)
  );

  {cpp_module_name} u_gemm_mac1 (
    .multiplicand(gemm_mac_a_vec1[7:0]),
    .multiplier(gemm_mac_b_vec1[7:0]),
    .accumulator(gemm_slot_accum1[15:0]),
    .result(gemm_mac_next1)
  );
"""
        compute_accum_update = """      if (gemm_slot_valid[0] && !gemm_slot_done[0]) begin
        gemm_slot_accum0 <= $signed(gemm_mac_next0);
      end
      if (gemm_slot_valid[1] && !gemm_slot_done[1]) begin
        gemm_slot_accum1 <= $signed(gemm_mac_next1);
      end
"""
    else:
        gemm_compute_instances = f"""
  wire signed [{gemm_accum_width_minus1}:0] gemm_mac_dot0;
  wire signed [{gemm_accum_width_minus1}:0] gemm_mac_dot1;

  gemm_mac_{gemm_mac_type} #(
    .LANES({gemm_mac_lanes}),
    .ACC_WIDTH({gemm_accum_width})
  ) u_gemm_mac0 (
    .a_vec(gemm_mac_a_vec0),
    .b_vec(gemm_mac_b_vec0),
    .acc_out(gemm_mac_dot0)
  );

  gemm_mac_{gemm_mac_type} #(
    .LANES({gemm_mac_lanes}),
    .ACC_WIDTH({gemm_accum_width})
  ) u_gemm_mac1 (
    .a_vec(gemm_mac_a_vec1),
    .b_vec(gemm_mac_b_vec1),
    .acc_out(gemm_mac_dot1)
  );
"""
        compute_accum_update = """      if (gemm_slot_valid[0] && !gemm_slot_done[0]) begin
        gemm_slot_accum0 <= gemm_slot_accum0 + gemm_mac_dot0;
      end
      if (gemm_slot_valid[1] && !gemm_slot_done[1]) begin
        gemm_slot_accum1 <= gemm_slot_accum1 + gemm_mac_dot1;
      end
"""
    def vec_lane_body(
        use_cpp_op: bool, module_name: str, inst_suffix: str, out_wire: str, builtin_body: str
    ) -> str:
        if use_cpp_op:
            return f"""      {module_name} u_vec_{inst_suffix} (
        .X(vec_in0[(gi*8) +: 8]),
        .Y({out_wire}[(gi*8) +: 8])
      );"""
        return builtin_body

    relu_lane_body = vec_lane_body(
        use_cpp_relu,
        vec_cpp_relu_module,
        "relu",
        "vec_relu_res",
        """      assign vec_relu_res[(gi*8) +: 8] = vec_in0[(gi*8)+7] ? 8'h00 : vec_in0[(gi*8) +: 8];""",
    )
    gelu_lane_body = vec_lane_body(
        use_cpp_gelu,
        vec_cpp_gelu_module,
        "gelu",
        "vec_gelu_res",
        """      assign vec_gelu_res[(gi*8) +: 8] = vec_in0[(gi*8)+7] ? 8'h00 : ($signed(vec_in0[(gi*8) +: 8]) >>> 1);""",
    )
    softmax_lane_body = vec_lane_body(
        use_cpp_softmax,
        vec_cpp_softmax_module,
        "softmax",
        "vec_softmax_res",
        """      assign vec_softmax_res[(gi*8) +: 8] = vec_in0[(gi*8)+7] ? 8'h00 : (($signed(vec_in0[(gi*8) +: 8]) > 8'sd31) ? 8'd127 : (vec_in0[(gi*8) +: 8] << 2));""",
    )
    layernorm_lane_body = vec_lane_body(
        use_cpp_layernorm,
        vec_cpp_layernorm_module,
        "layernorm",
        "vec_layernorm_res",
        """      assign vec_layernorm_res[(gi*8) +: 8] = $signed(vec_in0[(gi*8) +: 8]) >>> 1;""",
    )
    drelu_lane_body = vec_lane_body(
        use_cpp_drelu,
        vec_cpp_drelu_module,
        "drelu",
        "vec_drelu_res",
        """      assign vec_drelu_res[(gi*8) +: 8] = ($signed(vec_in0[(gi*8) +: 8]) > 0) ? 8'h01 : 8'h00;""",
    )
    dgelu_lane_body = vec_lane_body(
        use_cpp_dgelu,
        vec_cpp_dgelu_module,
        "dgelu",
        "vec_dgelu_res",
        """      assign vec_dgelu_res[(gi*8) +: 8] = ($signed(vec_in0[(gi*8) +: 8]) > 0) ? 8'h01 : 8'h00;""",
    )
    dsoftmax_lane_body = vec_lane_body(
        use_cpp_dsoftmax,
        vec_cpp_dsoftmax_module,
        "dsoftmax",
        "vec_dsoftmax_res",
        """      wire [7:0] vec_dsoftmax_p = vec_softmax_res[(gi*8) +: 8];
      wire [15:0] vec_dsoftmax_mul = vec_dsoftmax_p * (8'd127 - vec_dsoftmax_p);
      assign vec_dsoftmax_res[(gi*8) +: 8] = vec_dsoftmax_mul[14:7];""",
    )
    dlayernorm_lane_body = vec_lane_body(
        use_cpp_dlayernorm,
        vec_cpp_dlayernorm_module,
        "dlayernorm",
        "vec_dlayernorm_res",
        """      assign vec_dlayernorm_res[(gi*8) +: 8] = 8'h01;""",
    )

    vec_compute_instances = f"""
  wire [{vec_data_width_minus1}:0] vec_add_res;
  wire [{vec_data_width_minus1}:0] vec_mul_res;
  wire [{vec_data_width_minus1}:0] vec_relu_res;
  wire [{vec_data_width_minus1}:0] vec_gelu_res;
  wire [{vec_data_width_minus1}:0] vec_softmax_res;
  wire [{vec_data_width_minus1}:0] vec_layernorm_res;
  wire [{vec_data_width_minus1}:0] vec_drelu_res;
  wire [{vec_data_width_minus1}:0] vec_dgelu_res;
  wire [{vec_data_width_minus1}:0] vec_dsoftmax_res;
  wire [{vec_data_width_minus1}:0] vec_dlayernorm_res;
  wire [{vec_data_width_minus1}:0] vec_result_next;

  genvar gi;
  generate
    for (gi = 0; gi < {vec_lanes}; gi = gi + 1) begin : g_vec_lane
      assign vec_add_res[(gi*8) +: 8] = $signed(vec_in0[(gi*8) +: 8]) + $signed(vec_in1[(gi*8) +: 8]);
      assign vec_mul_res[(gi*8) +: 8] = $signed(vec_in0[(gi*8) +: 8]) * $signed(vec_in1[(gi*8) +: 8]);
{relu_lane_body}
{gelu_lane_body}
{softmax_lane_body}
{layernorm_lane_body}
{drelu_lane_body}
{dgelu_lane_body}
{dsoftmax_lane_body}
{dlayernorm_lane_body}
    end
  endgenerate

  assign vec_result_next = (vec_op_sel == VEC_OP_ADD) ? vec_add_res :
                           (vec_op_sel == VEC_OP_MUL) ? vec_mul_res :
                           (vec_op_sel == VEC_OP_GELU) ? vec_gelu_res :
                           (vec_op_sel == VEC_OP_SOFTMAX) ? vec_softmax_res :
                           (vec_op_sel == VEC_OP_LAYERNORM) ? vec_layernorm_res :
                           (vec_op_sel == VEC_OP_DRELU) ? vec_drelu_res :
                           (vec_op_sel == VEC_OP_DGELU) ? vec_dgelu_res :
                           (vec_op_sel == VEC_OP_DSOFTMAX) ? vec_dsoftmax_res :
                           (vec_op_sel == VEC_OP_DLAYERNORM) ? vec_dlayernorm_res :
                           vec_relu_res;
"""
    compute_instances = gemm_compute_instances + vec_compute_instances

    vec_update = """      vec_done_pulse <= 1'b0;
      if (vec_pending) begin
        vec_last_result <= vec_result_next;
        vec_pending <= 1'b0;
        vec_done_pulse <= 1'b1;
        irq_status[IRQ_EVENT] <= 1'b1;
      end
"""

    compute_reset = """      gemm_mac_a_vec0 <= 0;
      gemm_mac_b_vec0 <= 0;
      gemm_mac_a_vec1 <= 0;
      gemm_mac_b_vec1 <= 0;
      gemm_slot_accum0 <= 0;
      gemm_slot_accum1 <= 0;
      vec_in0 <= 0;
      vec_in1 <= 0;
      vec_last_result <= 0;
      vec_op_sel <= 0;
      vec_pending <= 0;
      vec_done_pulse <= 0;"""

    if compute_enabled:
        gemm_slot_init0_v1 = f"""                gemm_mac_a_vec0 <= cq_mem_rdata[{gemm_a_hi}:64];
                gemm_mac_b_vec0 <= cq_mem_rdata[{gemm_b_hi}:128];
                gemm_slot_accum0 <= 0;"""
        gemm_slot_init1_v1 = f"""                gemm_mac_a_vec1 <= cq_mem_rdata[{gemm_a_hi}:64];
                gemm_mac_b_vec1 <= cq_mem_rdata[{gemm_b_hi}:128];
                gemm_slot_accum1 <= 0;"""
        gemm_slot_init0_v2 = f"""                gemm_mac_a_vec0 <= cq_word0[{gemm_a_hi}:64];
                gemm_mac_b_vec0 <= cq_word0[{gemm_b_hi}:128];
                gemm_slot_accum0 <= 0;"""
        gemm_slot_init1_v2 = f"""                gemm_mac_a_vec1 <= cq_word0[{gemm_a_hi}:64];
                gemm_mac_b_vec1 <= cq_word0[{gemm_b_hi}:128];
                gemm_slot_accum1 <= 0;"""
    else:
        compute_accum_update = ""
        vec_update = ""
        gemm_slot_init0_v1 = ""
        gemm_slot_init1_v1 = ""
        gemm_slot_init0_v2 = ""
        gemm_slot_init1_v2 = ""

    enable_dma_ports = bool(cfg.get("enable_dma_ports", False))
    enable_cq_mem_ports = bool(cfg.get("enable_cq_mem_ports", False))
    enable_axi_ports = bool(cfg.get("enable_axi_ports", False))
    sram_instances = cfg.get("sram_instances", [])
    if enable_dma_ports:
        dma_ports = f""",
    output reg                   dma_req_valid,
    output reg  [{dma_addr_width_minus1}:0] dma_req_src,
    output reg  [{dma_addr_width_minus1}:0] dma_req_dst,
    output reg  [31:0]           dma_req_bytes,
    input  wire                  dma_req_ready,
    input  wire                  dma_resp_done
"""
        dma_reset = """      dma_req_valid <= 0;
      dma_req_src <= 0;
      dma_req_dst <= 0;
      dma_req_bytes <= 0;"""
        dma_handshake = """      if (dma_req_valid && dma_req_ready) begin
        dma_req_valid <= 0;
      end
      if (dma_resp_done) begin
        irq_status[IRQ_EVENT] <= 1'b1;
      end"""
        dma_kick = """            // DMA request will be issued when DMA_COPY descriptor is fetched."""
    else:
        dma_ports = ""
        dma_reset = ""
        dma_handshake = ""
        dma_kick = ""

    gemm_update = f"""      // Two-slot GEMM stub with OOO-capable completion scheduling.
      gemm_done_pulse <= 1'b0;
{vec_update}\
{compute_accum_update}\
      if (gemm_slot_valid[0] && !gemm_slot_done[0]) begin
        if (gemm_slot_cycles0 != 0) begin
          gemm_slot_cycles0 <= gemm_slot_cycles0 - 1;
          if (gemm_slot_cycles0 == 1) begin
            gemm_slot_done[0] <= 1'b1;
            gemm_done_pulse <= 1'b1;
            gemm_done_uid <= gemm_slot_uid0;
          end
        end else begin
          gemm_slot_done[0] <= 1'b1;
          gemm_done_pulse <= 1'b1;
          gemm_done_uid <= gemm_slot_uid0;
        end
      end
      if (gemm_slot_valid[1] && !gemm_slot_done[1]) begin
        if (gemm_slot_cycles1 != 0) begin
          gemm_slot_cycles1 <= gemm_slot_cycles1 - 1;
          if (gemm_slot_cycles1 == 1) begin
            gemm_slot_done[1] <= 1'b1;
            gemm_done_pulse <= 1'b1;
            gemm_done_uid <= gemm_slot_uid1;
          end
        end else begin
          gemm_slot_done[1] <= 1'b1;
          gemm_done_pulse <= 1'b1;
          gemm_done_uid <= gemm_slot_uid1;
        end
      end
      // Prefer slot1 if both are done, so completion order can differ from issue order.
      if (!dma_pending) begin
        if (gemm_slot_done[1]) begin
          dma_src <= gemm_slot_src1;
          dma_dst <= gemm_slot_dst1;
          dma_size <= gemm_slot_size1;
          dma_beats <= gemm_slot_beats1;
          dma_arlen <= gemm_slot_arlen1;
          dma_pending <= 1'b1;
          gemm_slot_valid[1] <= 1'b0;
          gemm_slot_done[1] <= 1'b0;
          gemm_dma_sel <= 1'b1;
        end else if (gemm_slot_done[0]) begin
          dma_src <= gemm_slot_src0;
          dma_dst <= gemm_slot_dst0;
          dma_size <= gemm_slot_size0;
          dma_beats <= gemm_slot_beats0;
          dma_arlen <= gemm_slot_arlen0;
          dma_pending <= 1'b1;
          gemm_slot_valid[0] <= 1'b0;
          gemm_slot_done[0] <= 1'b0;
          gemm_dma_sel <= 1'b0;
        end
      end
      gemm_pending <= (gemm_slot_valid != 2'b00);"""

    if enable_cq_mem_ports:
        cq_mem_ports = f""",
    output reg  [{dma_addr_width_minus1}:0] cq_mem_addr,
    input  wire [255:0]          cq_mem_rdata
"""
        cq_block = f"""      // Command queue fetch (supports v0.1 32B and v0.2 64B descriptors).
      if (cq_count != 0) begin
        if (!cq_stage_valid && !cq_pending_ext) begin
          cq_mem_addr <= {{cq_base_hi, cq_base_lo}} + cq_head;
          cq_stage_valid <= 1'b1;
        end else if (cq_stage_valid && !cq_pending_ext) begin
          cq_word0 <= cq_mem_rdata;
          cq_word0_size <= cq_mem_rdata[23:16];
          if (cq_mem_rdata[23:16] >= 8'h02) begin
            cq_pending_ext <= 1'b1;
            cq_stage_valid <= 1'b0;
          end else begin
            last_opcode <= cq_mem_rdata[7:0];
            last_tag <= cq_mem_rdata[63:32];
            last_src <= cq_mem_rdata[127:64];
            last_dst <= cq_mem_rdata[191:128];
            last_size <= cq_mem_rdata[223:192];
            last_op_uid <= 0;
            if (cq_mem_rdata[7:0] == 8'h01) begin
              dma_req_valid <= 1'b1;
              dma_req_src <= cq_mem_rdata[127:64];
              dma_req_dst <= cq_mem_rdata[191:128];
              dma_req_bytes <= cq_mem_rdata[223:192];
              dma_src <= cq_mem_rdata[127:64];
              dma_dst <= cq_mem_rdata[191:128];
              dma_size <= cq_mem_rdata[223:192];
              dma_beats <= {dma_beats_expr};
              dma_arlen <= {dma_arlen_expr};
              dma_pending <= 1'b1;
            end else if (cq_mem_rdata[7:0] == 8'h10) begin
              // GEMM stub: v0.1 sizes packed in TAG.
              if (!gemm_slot_valid[0]) begin
                gemm_slot_valid[0] <= 1'b1;
                gemm_slot_done[0] <= 1'b0;
                gemm_slot_uid0 <= 64'h0;
{gemm_slot_init0_v1}
                if ((cq_mem_rdata[63:52] == 0) || (cq_mem_rdata[51:42] == 0) || (cq_mem_rdata[41:32] == 0)) begin
                  gemm_slot_cycles0 <= 1;
                end else begin
                  gemm_slot_cycles0 <= (((cq_mem_rdata[63:52] * cq_mem_rdata[51:42] * cq_mem_rdata[41:32]) >> 10) + 1);
                end
                gemm_slot_src0 <= cq_mem_rdata[127:64];
                gemm_slot_dst0 <= cq_mem_rdata[255:192];
                gemm_slot_size0 <= ((cq_mem_rdata[11:8] == 4'h1 || cq_mem_rdata[11:8] == 4'h2)
                                    ? (cq_mem_rdata[63:52] * cq_mem_rdata[51:42] * 2)
                                    : (cq_mem_rdata[63:52] * cq_mem_rdata[51:42]));
                gemm_slot_beats0 <= (((((cq_mem_rdata[11:8] == 4'h1 || cq_mem_rdata[11:8] == 4'h2)
                                        ? (cq_mem_rdata[63:52] * cq_mem_rdata[51:42] * 2)
                                        : (cq_mem_rdata[63:52] * cq_mem_rdata[51:42]))
                                       + AXI_BEAT_BYTES - 1) >> {axi_size}));
                gemm_slot_arlen0 <= (((((cq_mem_rdata[11:8] == 4'h1 || cq_mem_rdata[11:8] == 4'h2)
                                        ? (cq_mem_rdata[63:52] * cq_mem_rdata[51:42] * 2)
                                        : (cq_mem_rdata[63:52] * cq_mem_rdata[51:42]))
                                       + AXI_BEAT_BYTES - 1) >> {axi_size}) - 1);
              end else if (!gemm_slot_valid[1]) begin
                gemm_slot_valid[1] <= 1'b1;
                gemm_slot_done[1] <= 1'b0;
                gemm_slot_uid1 <= 64'h0;
{gemm_slot_init1_v1}
                if ((cq_mem_rdata[63:52] == 0) || (cq_mem_rdata[51:42] == 0) || (cq_mem_rdata[41:32] == 0)) begin
                  gemm_slot_cycles1 <= 1;
                end else begin
                  gemm_slot_cycles1 <= (((cq_mem_rdata[63:52] * cq_mem_rdata[51:42] * cq_mem_rdata[41:32]) >> 10) + 1);
                end
                gemm_slot_src1 <= cq_mem_rdata[127:64];
                gemm_slot_dst1 <= cq_mem_rdata[255:192];
                gemm_slot_size1 <= ((cq_mem_rdata[11:8] == 4'h1 || cq_mem_rdata[11:8] == 4'h2)
                                    ? (cq_mem_rdata[63:52] * cq_mem_rdata[51:42] * 2)
                                    : (cq_mem_rdata[63:52] * cq_mem_rdata[51:42]));
                gemm_slot_beats1 <= (((((cq_mem_rdata[11:8] == 4'h1 || cq_mem_rdata[11:8] == 4'h2)
                                        ? (cq_mem_rdata[63:52] * cq_mem_rdata[51:42] * 2)
                                        : (cq_mem_rdata[63:52] * cq_mem_rdata[51:42]))
                                       + AXI_BEAT_BYTES - 1) >> {axi_size}));
                gemm_slot_arlen1 <= (((((cq_mem_rdata[11:8] == 4'h1 || cq_mem_rdata[11:8] == 4'h2)
                                        ? (cq_mem_rdata[63:52] * cq_mem_rdata[51:42] * 2)
                                        : (cq_mem_rdata[63:52] * cq_mem_rdata[51:42]))
                                       + AXI_BEAT_BYTES - 1) >> {axi_size}) - 1);
              end else begin
                error_code <= 32'h2; // GEMM in-flight queue full
              end
            end else if (cq_mem_rdata[7:0] == 8'h11) begin
              // VEC_OP (v0.1): input vectors are carried in descriptor payload bytes.
              if (vec_pending) begin
                error_code <= 32'h3; // VEC in-flight queue full
              end else begin
                vec_in0 <= cq_mem_rdata[{vec_a_hi}:64];
                vec_in1 <= cq_mem_rdata[{vec_b_hi}:128];
                vec_op_sel <= cq_mem_rdata[11:8];
                if ((cq_mem_rdata[11:8] == VEC_OP_ADD       && !VEC_EN_ADD)       ||
                    (cq_mem_rdata[11:8] == VEC_OP_MUL       && !VEC_EN_MUL)       ||
                    (cq_mem_rdata[11:8] == VEC_OP_RELU      && !VEC_EN_RELU)      ||
                    (cq_mem_rdata[11:8] == VEC_OP_GELU      && !VEC_EN_GELU)      ||
                    (cq_mem_rdata[11:8] == VEC_OP_SOFTMAX   && !VEC_EN_SOFTMAX)   ||
                    (cq_mem_rdata[11:8] == VEC_OP_LAYERNORM && !VEC_EN_LAYERNORM) ||
                    (cq_mem_rdata[11:8] == VEC_OP_DRELU     && !VEC_EN_DRELU)     ||
                    (cq_mem_rdata[11:8] == VEC_OP_DGELU     && !VEC_EN_DGELU)     ||
                    (cq_mem_rdata[11:8] == VEC_OP_DSOFTMAX  && !VEC_EN_DSOFTMAX)  ||
                    (cq_mem_rdata[11:8] == VEC_OP_DLAYERNORM&& !VEC_EN_DLAYERNORM)||
                    ((cq_mem_rdata[11:8] != VEC_OP_RELU)      &&
                     (cq_mem_rdata[11:8] != VEC_OP_ADD)       &&
                     (cq_mem_rdata[11:8] != VEC_OP_MUL)       &&
                     (cq_mem_rdata[11:8] != VEC_OP_GELU)      &&
                     (cq_mem_rdata[11:8] != VEC_OP_SOFTMAX)   &&
                     (cq_mem_rdata[11:8] != VEC_OP_LAYERNORM) &&
                     (cq_mem_rdata[11:8] != VEC_OP_DRELU)     &&
                     (cq_mem_rdata[11:8] != VEC_OP_DGELU)     &&
                     (cq_mem_rdata[11:8] != VEC_OP_DSOFTMAX)  &&
                     (cq_mem_rdata[11:8] != VEC_OP_DLAYERNORM))) begin
                  error_code <= 32'h6; // unsupported configured VEC op
                end else begin
                  vec_pending <= 1'b1;
                end
              end
            end else if (cq_mem_rdata[7:0] == 8'h20) begin
              // EVENT_SIGNAL: immediately signal
              irq_status[IRQ_EVENT] <= 1'b1;
            end else if (cq_mem_rdata[7:0] == 8'h21) begin
              // EVENT_WAIT: stubbed as immediately satisfied
              irq_status[IRQ_EVENT] <= 1'b1;
            end else begin
              error_code <= 32'h1;
            end
            cq_head <= cq_head + 32;
            if (cq_count == 1) begin
              irq_status[IRQ_CQ_EMPTY] <= 1'b1;
            end
            cq_count <= cq_count - 1;
            cq_stage_valid <= 1'b0;
          end
        end else if (cq_pending_ext) begin
          if (!cq_stage_valid) begin
            cq_mem_addr <= {{cq_base_hi, cq_base_lo}} + cq_head + 32;
            cq_stage_valid <= 1'b1;
          end else begin
            last_opcode <= cq_word0[7:0];
            last_tag <= cq_word0[63:32];
            last_src <= cq_word0[127:64];
            last_dst <= cq_word0[191:128];
            last_size <= cq_mem_rdata[31:0];
            last_op_uid <= cq_mem_rdata[255:192];
            if (cq_word0[7:0] == 8'h10) begin
              // GEMM stub: v0.2 sizes in extension.
              if (!gemm_slot_valid[0]) begin
                gemm_slot_valid[0] <= 1'b1;
                gemm_slot_done[0] <= 1'b0;
                gemm_slot_uid0 <= cq_mem_rdata[255:192];
{gemm_slot_init0_v2}
                if ((cq_mem_rdata[31:0] == 0) || (cq_mem_rdata[63:32] == 0) || (cq_mem_rdata[95:64] == 0)) begin
                  gemm_slot_cycles0 <= 1;
                end else begin
                  // Optional UID-based jitter (bit63) to exercise OOO completion in tests.
                  gemm_slot_cycles0 <= (((cq_mem_rdata[31:0] * cq_mem_rdata[63:32] * cq_mem_rdata[95:64]) >> 10)
                                        + 1 + (cq_mem_rdata[255] ? 8 : 0));
                end
                gemm_slot_src0 <= cq_word0[127:64];
                gemm_slot_dst0 <= cq_word0[255:192];
                gemm_slot_size0 <= ((cq_word0[11:8] == 4'h1 || cq_word0[11:8] == 4'h2)
                                    ? (cq_mem_rdata[31:0] * cq_mem_rdata[63:32] * 2)
                                    : (cq_mem_rdata[31:0] * cq_mem_rdata[63:32]));
                gemm_slot_beats0 <= (((((cq_word0[11:8] == 4'h1 || cq_word0[11:8] == 4'h2)
                                        ? (cq_mem_rdata[31:0] * cq_mem_rdata[63:32] * 2)
                                        : (cq_mem_rdata[31:0] * cq_mem_rdata[63:32]))
                                       + AXI_BEAT_BYTES - 1) >> {axi_size}));
                gemm_slot_arlen0 <= (((((cq_word0[11:8] == 4'h1 || cq_word0[11:8] == 4'h2)
                                        ? (cq_mem_rdata[31:0] * cq_mem_rdata[63:32] * 2)
                                        : (cq_mem_rdata[31:0] * cq_mem_rdata[63:32]))
                                       + AXI_BEAT_BYTES - 1) >> {axi_size}) - 1);
              end else if (!gemm_slot_valid[1]) begin
                gemm_slot_valid[1] <= 1'b1;
                gemm_slot_done[1] <= 1'b0;
                gemm_slot_uid1 <= cq_mem_rdata[255:192];
{gemm_slot_init1_v2}
                if ((cq_mem_rdata[31:0] == 0) || (cq_mem_rdata[63:32] == 0) || (cq_mem_rdata[95:64] == 0)) begin
                  gemm_slot_cycles1 <= 1;
                end else begin
                  gemm_slot_cycles1 <= (((cq_mem_rdata[31:0] * cq_mem_rdata[63:32] * cq_mem_rdata[95:64]) >> 10)
                                        + 1 + (cq_mem_rdata[255] ? 8 : 0));
                end
                gemm_slot_src1 <= cq_word0[127:64];
                gemm_slot_dst1 <= cq_word0[255:192];
                gemm_slot_size1 <= ((cq_word0[11:8] == 4'h1 || cq_word0[11:8] == 4'h2)
                                    ? (cq_mem_rdata[31:0] * cq_mem_rdata[63:32] * 2)
                                    : (cq_mem_rdata[31:0] * cq_mem_rdata[63:32]));
                gemm_slot_beats1 <= (((((cq_word0[11:8] == 4'h1 || cq_word0[11:8] == 4'h2)
                                        ? (cq_mem_rdata[31:0] * cq_mem_rdata[63:32] * 2)
                                        : (cq_mem_rdata[31:0] * cq_mem_rdata[63:32]))
                                       + AXI_BEAT_BYTES - 1) >> {axi_size}));
                gemm_slot_arlen1 <= (((((cq_word0[11:8] == 4'h1 || cq_word0[11:8] == 4'h2)
                                        ? (cq_mem_rdata[31:0] * cq_mem_rdata[63:32] * 2)
                                        : (cq_mem_rdata[31:0] * cq_mem_rdata[63:32]))
                                       + AXI_BEAT_BYTES - 1) >> {axi_size}) - 1);
              end else begin
                error_code <= 32'h2; // GEMM in-flight queue full
              end
            end else if (cq_word0[7:0] == 8'h11) begin
              // VEC_OP (v0.2 base word): vectors are sourced from header payload.
              if (vec_pending) begin
                error_code <= 32'h3; // VEC in-flight queue full
              end else begin
                vec_in0 <= cq_word0[{vec_a_hi}:64];
                vec_in1 <= cq_word0[{vec_b_hi}:128];
                vec_op_sel <= cq_word0[11:8];
                if ((cq_word0[11:8] == VEC_OP_ADD       && !VEC_EN_ADD)       ||
                    (cq_word0[11:8] == VEC_OP_MUL       && !VEC_EN_MUL)       ||
                    (cq_word0[11:8] == VEC_OP_RELU      && !VEC_EN_RELU)      ||
                    (cq_word0[11:8] == VEC_OP_GELU      && !VEC_EN_GELU)      ||
                    (cq_word0[11:8] == VEC_OP_SOFTMAX   && !VEC_EN_SOFTMAX)   ||
                    (cq_word0[11:8] == VEC_OP_LAYERNORM && !VEC_EN_LAYERNORM) ||
                    (cq_word0[11:8] == VEC_OP_DRELU     && !VEC_EN_DRELU)     ||
                    (cq_word0[11:8] == VEC_OP_DGELU     && !VEC_EN_DGELU)     ||
                    (cq_word0[11:8] == VEC_OP_DSOFTMAX  && !VEC_EN_DSOFTMAX)  ||
                    (cq_word0[11:8] == VEC_OP_DLAYERNORM&& !VEC_EN_DLAYERNORM)||
                    ((cq_word0[11:8] != VEC_OP_RELU)      &&
                     (cq_word0[11:8] != VEC_OP_ADD)       &&
                     (cq_word0[11:8] != VEC_OP_MUL)       &&
                     (cq_word0[11:8] != VEC_OP_GELU)      &&
                     (cq_word0[11:8] != VEC_OP_SOFTMAX)   &&
                     (cq_word0[11:8] != VEC_OP_LAYERNORM) &&
                     (cq_word0[11:8] != VEC_OP_DRELU)     &&
                     (cq_word0[11:8] != VEC_OP_DGELU)     &&
                     (cq_word0[11:8] != VEC_OP_DSOFTMAX)  &&
                     (cq_word0[11:8] != VEC_OP_DLAYERNORM))) begin
                  error_code <= 32'h6;
                end else begin
                  vec_pending <= 1'b1;
                end
              end
            end else begin
              error_code <= 32'h1;
            end
            if (cq_count <= cq_word0_size) begin
              irq_status[IRQ_CQ_EMPTY] <= 1'b1;
            end
            cq_head <= cq_head + (cq_word0_size * 32);
            cq_count <= cq_count - cq_word0_size;
            cq_stage_valid <= 1'b0;
            cq_pending_ext <= 1'b0;
          end
        end
      end"""
    else:
        cq_mem_ports = ""
        cq_block = ""

    if enable_axi_ports:
        axi_ports = f""",
    output reg                   m_axi_awvalid,
    input  wire                  m_axi_awready,
    output reg  [{axi_addr_width_minus1}:0] m_axi_awaddr,
    output reg  [7:0]            m_axi_awlen,
    output reg  [2:0]            m_axi_awsize,
    output reg                   m_axi_wvalid,
    input  wire                  m_axi_wready,
    output reg  [{axi_data_width_minus1}:0] m_axi_wdata,
    output reg  [{axi_strb_width_minus1}:0] m_axi_wstrb,
    output reg                   m_axi_wlast,
    input  wire                  m_axi_bvalid,
    output reg                   m_axi_bready,
    output reg                   m_axi_arvalid,
    input  wire                  m_axi_arready,
    output reg  [{axi_addr_width_minus1}:0] m_axi_araddr,
    output reg  [7:0]            m_axi_arlen,
    output reg  [2:0]            m_axi_arsize,
    input  wire                  m_axi_rvalid,
    output reg                   m_axi_rready,
    input  wire [{axi_data_width_minus1}:0] m_axi_rdata,
    input  wire                  m_axi_rlast
"""
        axi_defaults = """      m_axi_awvalid <= 1'b0;
      m_axi_awaddr <= 0;
      m_axi_awlen <= 0;
      m_axi_awsize <= 0;
      m_axi_wvalid <= 1'b0;
      m_axi_wdata <= 0;
      m_axi_wstrb <= 0;
      m_axi_wlast <= 1'b0;
      m_axi_bready <= 1'b0;
      m_axi_arvalid <= 1'b0;
      m_axi_araddr <= 0;
      m_axi_arlen <= 0;
      m_axi_arsize <= 0;
      m_axi_rready <= 1'b0;"""
        axi_fsm = f"""      // AXI DMA shim: burst read then burst write.
      case (dma_state)
        0: begin
          if (dma_pending) begin
            if (dma_beats_left == 0) begin
              dma_beats_left <= dma_beats;
              dma_rd_idx <= 0;
              dma_wr_idx <= 0;
            end
            m_axi_arvalid <= 1'b1;
            m_axi_araddr <= dma_src;
            m_axi_arlen <= dma_arlen;
            m_axi_arsize <= 3'd{axi_size}; // beat bytes = 2**{axi_size}
            if (m_axi_arready) begin
              dma_state <= 1;
            end
          end
        end
        1: begin
          m_axi_rready <= 1'b1;
          if (m_axi_rvalid) begin
            dma_buf_mem[dma_rd_idx] <= m_axi_rdata;
            dma_rd_idx <= dma_rd_idx + 1;
            if (m_axi_rlast) begin
              dma_state <= 2;
            end
          end
        end
        2: begin
          m_axi_awvalid <= 1'b1;
          m_axi_awaddr <= dma_dst;
          m_axi_awlen <= dma_arlen;
          m_axi_awsize <= 3'd{axi_size};
          if (m_axi_awready) begin
            dma_state <= 3;
          end
        end
        3: begin
          m_axi_wvalid <= 1'b1;
          m_axi_wdata <= dma_buf_mem[dma_wr_idx];
          m_axi_wstrb <= {{{axi_strb_width}{{1'b1}}}};
          m_axi_wlast <= (dma_beats_left == 1);
          if (m_axi_wready) begin
            if (dma_beats_left == 1) begin
              dma_state <= 4;
            end else begin
              dma_wr_idx <= dma_wr_idx + 1;
              dma_beats_left <= dma_beats_left - 1;
            end
          end
        end
        4: begin
          m_axi_bready <= 1'b1;
          if (m_axi_bvalid) begin
            dma_beats_left <= 0;
            dma_state <= 0;
            dma_pending <= 1'b0;
            irq_status[IRQ_EVENT] <= 1'b1;
          end
        end
        default: dma_state <= 0;
      endcase"""
        axi_reset = """      m_axi_awvalid <= 1'b0;
      m_axi_awaddr <= 0;
      m_axi_awlen <= 0;
      m_axi_awsize <= 0;
      m_axi_wvalid <= 1'b0;
      m_axi_wdata <= 0;
      m_axi_wstrb <= 0;
      m_axi_wlast <= 1'b0;
      m_axi_bready <= 1'b0;
      m_axi_arvalid <= 1'b0;
      m_axi_araddr <= 0;
      m_axi_arlen <= 0;
      m_axi_arsize <= 0;
      m_axi_rready <= 1'b0;"""
    else:
        axi_ports = ""
        axi_defaults = ""
        axi_fsm = ""
        axi_reset = ""

    verilog = TOP_TEMPLATE.format(
        compute_modules=compute_modules,
        top_name=top_name,
        mmio_addr_width_minus1=mmio_addr_width - 1,
        data_width_minus1=data_width - 1,
        dma_addr_width_minus1=dma_addr_width_minus1,
        dma_data_width_minus1=dma_data_width - 1,
        axi_addr_width_minus1=axi_addr_width_minus1,
        axi_data_width_minus1=axi_data_width_minus1,
        axi_strb_width_minus1=axi_strb_width_minus1,
        axi_beat_bytes=(1 << axi_size),
        vec_en_add=vec_en_add,
        vec_en_mul=vec_en_mul,
        vec_en_relu=vec_en_relu,
        vec_en_gelu=vec_en_gelu,
        vec_en_softmax=vec_en_softmax,
        vec_en_layernorm=vec_en_layernorm,
        vec_en_drelu=vec_en_drelu,
        vec_en_dgelu=vec_en_dgelu,
        vec_en_dsoftmax=vec_en_dsoftmax,
        vec_en_dlayernorm=vec_en_dlayernorm,
        gemm_mac_lanes=gemm_mac_lanes,
        gemm_elem_bits=gemm_elem_bits,
        gemm_fp16_raw16_placeholder=gemm_fp16_raw16_placeholder,
        gemm_fp16_accum_fp32=gemm_fp16_accum_fp32,
        vec_lanes=vec_lanes,
        dma_ports=dma_ports,
        compute_state_regs=compute_state_regs,
        dma_reset=dma_reset,
        compute_reset=compute_reset,
        dma_handshake=dma_handshake,
        dma_kick=dma_kick,
        gemm_update=gemm_update,
        cq_mem_ports=cq_mem_ports,
        cq_block=cq_block,
        compute_instances=compute_instances,
        axi_ports=axi_ports,
        axi_defaults=axi_defaults,
        axi_fsm=axi_fsm,
        axi_reset=axi_reset,
    )

    (out_path / "top.v").write_text(verilog, encoding="utf-8")
    (out_path / "config.json").write_text(json.dumps(cfg, indent=2) + "\n", encoding="utf-8")

    sram_map = []
    if sram_instances:
        models = [SRAM_1R1W_MODEL]
        next_base = 0x80000000
        for inst in sram_instances:
            if inst.get("port", "1r1w") != "1r1w":
                die(f"unsupported SRAM port type: {inst.get('port')}")
            read_latency = int(inst.get("read_latency", 1))
            if read_latency < 1:
                die("SRAM read_latency must be >= 1")
            sram_data_width = int(inst["width"])
            if sram_data_width % 8 != 0:
                die("SRAM width must be a multiple of 8")
            depth = int(inst["depth"])
            if depth < 2:
                die("SRAM depth must be >= 2")
            if (depth & (depth - 1)) != 0:
                die("SRAM depth must be a power of two")
            strb_width = sram_data_width // 8
            size_bytes = depth * strb_width * int(inst.get("banks", 1))
            base_addr = inst.get("base_addr")
            if base_addr is None:
                base_addr = next_base
                next_base += size_bytes
            if isinstance(base_addr, str):
                base_addr = int(base_addr, 0)
            alignment_bytes = int(inst.get("alignment_bytes", 64))
            word_bytes = sram_data_width // 8
            sram_map.append(
                {
                    "name": inst["name"],
                    "base_addr": base_addr,
                    "size_bytes": size_bytes,
                    "word_bytes": word_bytes,
                    "alignment_bytes": alignment_bytes,
                }
            )
            models.append(
                SRAM_1R1W_WRAPPER.format(
                    inst_name=inst["name"],
                    addr_width=depth.bit_length() - 1,
                    addr_width_minus1=depth.bit_length() - 2,
                    data_width=sram_data_width,
                    data_width_minus1=sram_data_width - 1,
                    strb_width_minus1=strb_width - 1,
                    read_latency=read_latency,
                    byte_enable=1 if bool(inst.get("byte_en", True)) else 0,
                )
            )
        (out_path / "sram_models.sv").write_text("\n\n".join(models) + "\n", encoding="utf-8")
        (out_path / "sram_map.json").write_text(json.dumps(sram_map, indent=2) + "\n", encoding="utf-8")

    if not sram_map:
        (out_path / "sram_map.json").write_text("[]\n", encoding="utf-8")

    count = len(sram_map)
    max_srams = 8
    vh_lines = [
        "localparam int SRAM_COUNT = %d;" % count,
        "localparam int SRAM_MAX = %d;" % max_srams,
    ]
    for idx in range(max_srams):
        if idx < count:
            entry = sram_map[idx]
            vh_lines.append("localparam logic [63:0] SRAM_BASE%d = 64'h%016x;" % (idx, entry["base_addr"]))
            vh_lines.append("localparam logic [63:0] SRAM_SIZE%d = %d;" % (idx, entry["size_bytes"]))
            vh_lines.append("localparam int SRAM_ALIGN%d = %d;" % (idx, entry["alignment_bytes"]))
            vh_lines.append("localparam int SRAM_WORD_BYTES%d = %d;" % (idx, entry["word_bytes"]))
        else:
            vh_lines.append("localparam logic [63:0] SRAM_BASE%d = 64'h0;" % idx)
            vh_lines.append("localparam logic [63:0] SRAM_SIZE%d = 0;" % idx)
            vh_lines.append("localparam int SRAM_ALIGN%d = 0;" % idx)
            vh_lines.append("localparam int SRAM_WORD_BYTES%d = 0;" % idx)
    (out_path / "sram_map.vh").write_text("\n".join(vh_lines) + "\n", encoding="utf-8")

    mmio_lines = [
        "localparam int OFF_VERSION    = 12'h000;",
        "localparam int OFF_CAPS       = 12'h004;",
        "localparam int OFF_STATUS     = 12'h008;",
        "localparam int OFF_CONTROL    = 12'h00C;",
        "localparam int OFF_IRQ_STATUS = 12'h010;",
        "localparam int OFF_IRQ_ENABLE = 12'h014;",
        "localparam int OFF_CQ_BASE_LO = 12'h020;",
        "localparam int OFF_CQ_BASE_HI = 12'h024;",
        "localparam int OFF_CQ_SIZE    = 12'h028;",
        "localparam int OFF_CQ_HEAD    = 12'h02C;",
        "localparam int OFF_CQ_TAIL    = 12'h030;",
        "localparam int OFF_DOORBELL   = 12'h040;",
        "localparam int OFF_ERROR_CODE = 12'h044;",
    ]
    (out_path / "mmio_map.vh").write_text("\n".join(mmio_lines) + "\n", encoding="utf-8")

    if bool(cfg.get("enable_axi_lite_wrapper", False)):
        bridge = AXI_LITE_BRIDGE.format(
            data_width_minus1=data_width - 1,
            mmio_addr_width_minus1=mmio_addr_width - 1,
        )
        wrapper = AXI_LITE_WRAPPER.format(
            top_name=top_name,
            mmio_addr_width_minus1=mmio_addr_width - 1,
            data_width_minus1=data_width - 1,
            dma_addr_width_minus1=dma_addr_width_minus1,
            axi_addr_width_minus1=axi_addr_width_minus1,
            axi_data_width_minus1=axi_data_width_minus1,
            axi_strb_width_minus1=axi_strb_width_minus1,
        )
        (out_path / "axi_lite_mmio_bridge.sv").write_text(bridge, encoding="utf-8")
        (out_path / "top_axi.v").write_text(wrapper, encoding="utf-8")


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate stub NPU RTL.")
    parser.add_argument("--config", required=True, help="Path to config JSON")
    parser.add_argument("--out", required=True, help="Output directory")
    args = parser.parse_args()

    cfg = load_config(args.config)
    write_outputs(cfg, args.out)
    print(f"rtlgen: wrote RTL to {args.out}")
    return 0


if __name__ == "__main__":
    sys.exit(main())
