#!/usr/bin/env python3
import argparse
import json
import os
import sys
from pathlib import Path


TOP_TEMPLATE = """\
// Auto-generated by npu/rtlgen/gen.py (v0.1)
module {top_name} (
    input  wire                  clk,
    input  wire                  rst_n,
    input  wire [{mmio_addr_width_minus1}:0] mmio_addr,
    input  wire                  mmio_we,
    input  wire [{data_width_minus1}:0] mmio_wdata,
    output reg  [{data_width_minus1}:0] mmio_rdata,
    output reg                   irq{dma_ports}{cq_mem_ports}{axi_ports}
);

  // Minimal stub: MMIO register block with queue bookkeeping.
  reg [{data_width_minus1}:0] version;
  reg [{data_width_minus1}:0] capabilities;
  reg [{data_width_minus1}:0] status;
  reg [{data_width_minus1}:0] control;
  reg [{data_width_minus1}:0] irq_status;
  reg [{data_width_minus1}:0] irq_enable;
  reg [{data_width_minus1}:0] cq_base_lo;
  reg [{data_width_minus1}:0] cq_base_hi;
  reg [{data_width_minus1}:0] cq_size;
  reg [{data_width_minus1}:0] cq_head;
  reg [{data_width_minus1}:0] cq_tail;
  reg [{data_width_minus1}:0] cq_count;
  reg [7:0] last_opcode;
  reg [31:0] last_tag;
  reg [63:0] last_src;
  reg [63:0] last_dst;
  reg [31:0] last_size;
  reg [63:0] dma_src;
  reg [63:0] dma_dst;
  reg [31:0] dma_size;
  reg        cq_stage_valid;
  reg        dma_pending;
  reg [2:0]  dma_state;
  reg [255:0] dma_buf;
  reg [8:0]  dma_beats;
  reg [8:0]  dma_beats_left;
  reg [7:0]  dma_arlen;
  reg [255:0] dma_buf_mem [0:255];
  reg [7:0]  dma_rd_idx;
  reg [7:0]  dma_wr_idx;
  reg [{data_width_minus1}:0] error_code;

  localparam STATUS_IDLE = 32'h1;
  localparam STATUS_BUSY = 32'h2;
  localparam STATUS_ERR  = 32'h4;

  localparam IRQ_CQ_EMPTY    = 0;
  localparam IRQ_EVENT       = 1;
  localparam IRQ_ERROR       = 2;

  // MMIO offsets (bytes)
  localparam OFF_VERSION     = 12'h000;
  localparam OFF_CAPS        = 12'h004;
  localparam OFF_STATUS      = 12'h008;
  localparam OFF_CONTROL     = 12'h00C;
  localparam OFF_IRQ_STATUS  = 12'h010;
  localparam OFF_IRQ_ENABLE  = 12'h014;
  localparam OFF_CQ_BASE_LO  = 12'h020;
  localparam OFF_CQ_BASE_HI  = 12'h024;
  localparam OFF_CQ_SIZE     = 12'h028;
  localparam OFF_CQ_HEAD     = 12'h02C;
  localparam OFF_CQ_TAIL     = 12'h030;
  localparam OFF_DOORBELL    = 12'h040;
  localparam OFF_ERROR_CODE  = 12'h044;

  always @(*) begin
    case (mmio_addr)
      OFF_VERSION:    mmio_rdata = version;
      OFF_CAPS:       mmio_rdata = capabilities;
      OFF_STATUS:     mmio_rdata = status;
      OFF_CONTROL:    mmio_rdata = control;
      OFF_IRQ_STATUS: mmio_rdata = irq_status;
      OFF_IRQ_ENABLE: mmio_rdata = irq_enable;
      OFF_CQ_BASE_LO: mmio_rdata = cq_base_lo;
      OFF_CQ_BASE_HI: mmio_rdata = cq_base_hi;
      OFF_CQ_SIZE:    mmio_rdata = cq_size;
      OFF_CQ_HEAD:    mmio_rdata = cq_head;
      OFF_CQ_TAIL:    mmio_rdata = cq_tail;
      OFF_ERROR_CODE: mmio_rdata = error_code;
      default: mmio_rdata = 0;
    endcase
  end

  always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
      version <= 32'h0001_0001;
      capabilities <= 32'h0000_0133; // DMA_COPY/STRIDED/GATHER/SCATTER + GEMM/VEC/SOFTMAX + EVENT_IRQ
      status <= STATUS_IDLE;
      control <= 0;
      irq_status <= 0;
      irq_enable <= 0;
      cq_base_lo <= 0;
      cq_base_hi <= 0;
      cq_size <= 0;
      cq_head <= 0;
      cq_tail <= 0;
      cq_count <= 0;
      error_code <= 0;
      irq <= 0;
      last_opcode <= 0;
      last_tag <= 0;
      last_src <= 0;
      last_dst <= 0;
      last_size <= 0;
      dma_src <= 0;
      dma_dst <= 0;
      dma_size <= 0;
      cq_stage_valid <= 0;
      dma_pending <= 0;
      dma_state <= 0;
      dma_buf <= 0;
      dma_beats <= 0;
      dma_beats_left <= 0;
      dma_arlen <= 0;
      dma_rd_idx <= 0;
      dma_wr_idx <= 0;
{dma_reset}
{axi_reset}
    end else begin
      // Default: clear level IRQ unless status bit set
      irq <= |(irq_status & irq_enable);
{dma_handshake}
{axi_defaults}
{axi_fsm}

      if (mmio_we) begin
        case (mmio_addr)
          OFF_CONTROL: control <= mmio_wdata;
          OFF_IRQ_STATUS: irq_status <= irq_status & ~mmio_wdata; // W1C
          OFF_IRQ_ENABLE: irq_enable <= mmio_wdata;
          OFF_CQ_BASE_LO: cq_base_lo <= mmio_wdata;
          OFF_CQ_BASE_HI: cq_base_hi <= mmio_wdata;
          OFF_CQ_SIZE:    cq_size <= mmio_wdata;
          OFF_CQ_TAIL:    cq_tail <= mmio_wdata;
          OFF_DOORBELL: begin
            // Minimal behavior: consume all queued descriptors.
            status <= STATUS_BUSY;
            cq_count <= (cq_tail >> 5);
            status <= STATUS_IDLE;
            irq_status[IRQ_CQ_EMPTY] <= 1'b1;
{dma_kick}
          end
          default: begin end
        endcase
      end

      // Two-stage descriptor fetch: issue read then decode next cycle.
      if (cq_count != 0) begin
        if (!cq_stage_valid) begin
{cq_mem_fetch_issue}
          cq_stage_valid <= 1'b1;
        end else begin
{cq_mem_fetch_decode}
          cq_head <= cq_head + 32;
          cq_count <= cq_count - 1;
          cq_stage_valid <= 1'b0;
        end
      end

      if (error_code != 0) begin
        status <= STATUS_ERR;
        irq_status[IRQ_ERROR] <= 1'b1;
      end
    end
  end

endmodule
"""

AXI_LITE_BRIDGE = """\
// Simple AXI-Lite to MMIO bridge (single-beat)
module axi_lite_mmio_bridge (
    input  wire                  clk,
    input  wire                  rst_n,
    // AXI-Lite slave interface
    input  wire [31:0]           s_axi_awaddr,
    input  wire                  s_axi_awvalid,
    output reg                   s_axi_awready,
    input  wire [{data_width_minus1}:0] s_axi_wdata,
    input  wire [(32/8)-1:0]    s_axi_wstrb,
    input  wire                  s_axi_wvalid,
    output reg                   s_axi_wready,
    output reg  [1:0]            s_axi_bresp,
    output reg                   s_axi_bvalid,
    input  wire                  s_axi_bready,
    input  wire [31:0]           s_axi_araddr,
    input  wire                  s_axi_arvalid,
    output reg                   s_axi_arready,
    output reg  [{data_width_minus1}:0] s_axi_rdata,
    output reg  [1:0]            s_axi_rresp,
    output reg                   s_axi_rvalid,
    input  wire                  s_axi_rready,
    // MMIO side
    output reg  [{mmio_addr_width_minus1}:0] mmio_addr,
    output reg                   mmio_we,
    output reg  [{data_width_minus1}:0] mmio_wdata,
    input  wire [{data_width_minus1}:0] mmio_rdata
);

  reg read_pending;

  always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
      s_axi_awready <= 1'b0;
      s_axi_wready <= 1'b0;
      s_axi_bvalid <= 1'b0;
      s_axi_bresp <= 2'b00;
      s_axi_arready <= 1'b0;
      s_axi_rvalid <= 1'b0;
      s_axi_rresp <= 2'b00;
      s_axi_rdata <= 0;
      mmio_addr <= 0;
      mmio_we <= 1'b0;
      mmio_wdata <= 0;
      read_pending <= 1'b0;
    end else begin
      s_axi_awready <= s_axi_awvalid;
      s_axi_wready <= s_axi_wvalid;
      s_axi_arready <= (!read_pending && !s_axi_rvalid);
      mmio_we <= 1'b0;

      if (s_axi_awvalid && s_axi_wvalid) begin
        mmio_addr <= s_axi_awaddr[{mmio_addr_width_minus1}:0];
        mmio_wdata <= s_axi_wdata;
        mmio_we <= 1'b1;
        s_axi_bvalid <= 1'b1;
        s_axi_bresp <= 2'b00;
      end

      if (s_axi_bvalid && s_axi_bready)
        s_axi_bvalid <= 1'b0;

      if (s_axi_arvalid && s_axi_arready) begin
        mmio_addr <= s_axi_araddr[{mmio_addr_width_minus1}:0];
        read_pending <= 1'b1;
      end

      if (read_pending && !s_axi_rvalid) begin
        s_axi_rdata <= mmio_rdata;
        s_axi_rvalid <= 1'b1;
        s_axi_rresp <= 2'b00;
        read_pending <= 1'b0;
      end

      if (s_axi_rvalid && s_axi_rready) begin
        s_axi_rvalid <= 1'b0;
      end
    end
  end

endmodule
"""

AXI_LITE_WRAPPER = """\
// Auto-generated AXI-Lite wrapper (v0.1)
module {top_name}_axi (
    input  wire                  clk,
    input  wire                  rst_n,
    // AXI-Lite slave
    input  wire [31:0]           s_axi_awaddr,
    input  wire                  s_axi_awvalid,
    output wire                  s_axi_awready,
    input  wire [31:0]           s_axi_wdata,
    input  wire [3:0]            s_axi_wstrb,
    input  wire                  s_axi_wvalid,
    output wire                  s_axi_wready,
    output wire [1:0]            s_axi_bresp,
    output wire                  s_axi_bvalid,
    input  wire                  s_axi_bready,
    input  wire [31:0]           s_axi_araddr,
    input  wire                  s_axi_arvalid,
    output wire                  s_axi_arready,
    output wire [31:0]           s_axi_rdata,
    output wire [1:0]            s_axi_rresp,
    output wire                  s_axi_rvalid,
    input  wire                  s_axi_rready,
    // Interrupt
    output wire                  irq,
    // DMA stub ports
    output wire                  dma_req_valid,
    output wire [63:0]           dma_req_src,
    output wire [63:0]           dma_req_dst,
    output wire [31:0]           dma_req_bytes,
    input  wire                  dma_req_ready,
    input  wire                  dma_resp_done,
    // CQ memory port
    output wire [63:0]           cq_mem_addr,
    input  wire [255:0]          cq_mem_rdata,
    // AXI memory master
    output wire                  m_axi_awvalid,
    input  wire                  m_axi_awready,
    output wire [63:0]           m_axi_awaddr,
    output wire [7:0]            m_axi_awlen,
    output wire [2:0]            m_axi_awsize,
    output wire                  m_axi_wvalid,
    input  wire                  m_axi_wready,
    output wire [255:0]          m_axi_wdata,
    output wire [31:0]           m_axi_wstrb,
    output wire                  m_axi_wlast,
    input  wire                  m_axi_bvalid,
    output wire                  m_axi_bready,
    output wire                  m_axi_arvalid,
    input  wire                  m_axi_arready,
    output wire [63:0]           m_axi_araddr,
    output wire [7:0]            m_axi_arlen,
    output wire [2:0]            m_axi_arsize,
    input  wire                  m_axi_rvalid,
    output wire                  m_axi_rready,
    input  wire [255:0]          m_axi_rdata,
    input  wire                  m_axi_rlast
);
  wire [11:0] mmio_addr;
  wire        mmio_we;
  wire [31:0] mmio_wdata;
  wire [31:0] mmio_rdata;

  axi_lite_mmio_bridge u_bridge (
    .clk(clk),
    .rst_n(rst_n),
    .s_axi_awaddr(s_axi_awaddr),
    .s_axi_awvalid(s_axi_awvalid),
    .s_axi_awready(s_axi_awready),
    .s_axi_wdata(s_axi_wdata),
    .s_axi_wstrb(s_axi_wstrb),
    .s_axi_wvalid(s_axi_wvalid),
    .s_axi_wready(s_axi_wready),
    .s_axi_bresp(s_axi_bresp),
    .s_axi_bvalid(s_axi_bvalid),
    .s_axi_bready(s_axi_bready),
    .s_axi_araddr(s_axi_araddr),
    .s_axi_arvalid(s_axi_arvalid),
    .s_axi_arready(s_axi_arready),
    .s_axi_rdata(s_axi_rdata),
    .s_axi_rresp(s_axi_rresp),
    .s_axi_rvalid(s_axi_rvalid),
    .s_axi_rready(s_axi_rready),
    .mmio_addr(mmio_addr),
    .mmio_we(mmio_we),
    .mmio_wdata(mmio_wdata),
    .mmio_rdata(mmio_rdata)
  );

  {top_name} u_top (
    .clk(clk),
    .rst_n(rst_n),
    .mmio_addr(mmio_addr),
    .mmio_we(mmio_we),
    .mmio_wdata(mmio_wdata),
    .mmio_rdata(mmio_rdata),
    .irq(irq),
    .dma_req_valid(dma_req_valid),
    .dma_req_src(dma_req_src),
    .dma_req_dst(dma_req_dst),
    .dma_req_bytes(dma_req_bytes),
    .dma_req_ready(dma_req_ready),
    .dma_resp_done(dma_resp_done),
    .cq_mem_addr(cq_mem_addr),
    .cq_mem_rdata(cq_mem_rdata),
    .m_axi_awvalid(m_axi_awvalid),
    .m_axi_awready(m_axi_awready),
    .m_axi_awaddr(m_axi_awaddr),
    .m_axi_awlen(m_axi_awlen),
    .m_axi_awsize(m_axi_awsize),
    .m_axi_wvalid(m_axi_wvalid),
    .m_axi_wready(m_axi_wready),
    .m_axi_wdata(m_axi_wdata),
    .m_axi_wstrb(m_axi_wstrb),
    .m_axi_wlast(m_axi_wlast),
    .m_axi_bvalid(m_axi_bvalid),
    .m_axi_bready(m_axi_bready),
    .m_axi_arvalid(m_axi_arvalid),
    .m_axi_arready(m_axi_arready),
    .m_axi_araddr(m_axi_araddr),
    .m_axi_arlen(m_axi_arlen),
    .m_axi_arsize(m_axi_arsize),
    .m_axi_rvalid(m_axi_rvalid),
    .m_axi_rready(m_axi_rready),
    .m_axi_rdata(m_axi_rdata),
    .m_axi_rlast(m_axi_rlast)
  );
endmodule
"""


def die(msg: str) -> None:
    print(f"rtlgen: {msg}", file=sys.stderr)
    sys.exit(1)


def load_config(path: str) -> dict:
    with open(path, "r", encoding="utf-8") as f:
        cfg = json.load(f)
    if cfg.get("version") != "0.1":
        die("config version must be 0.1")
    return cfg


def write_outputs(cfg: dict, out_dir: str) -> None:
    out_path = Path(out_dir)
    out_path.mkdir(parents=True, exist_ok=True)

    top_name = cfg["top_name"]
    mmio_addr_width = int(cfg["mmio_addr_width"])
    data_width = int(cfg["data_width"])

    enable_dma_ports = bool(cfg.get("enable_dma_ports", False))
    enable_cq_mem_ports = bool(cfg.get("enable_cq_mem_ports", False))
    enable_axi_ports = bool(cfg.get("enable_axi_ports", False))
    if enable_dma_ports:
        dma_ports = """,
    output reg                   dma_req_valid,
    output reg  [63:0]           dma_req_src,
    output reg  [63:0]           dma_req_dst,
    output reg  [31:0]           dma_req_bytes,
    input  wire                  dma_req_ready,
    input  wire                  dma_resp_done
"""
        dma_reset = """      dma_req_valid <= 0;
      dma_req_src <= 0;
      dma_req_dst <= 0;
      dma_req_bytes <= 0;"""
        dma_handshake = """      if (dma_req_valid && dma_req_ready) begin
        dma_req_valid <= 0;
      end
      if (dma_resp_done) begin
        irq_status[IRQ_EVENT] <= 1'b1;
      end"""
        dma_kick = """            // DMA request will be issued when DMA_COPY descriptor is fetched."""
    else:
        dma_ports = ""
        dma_reset = ""
        dma_handshake = ""
        dma_kick = ""

    if enable_cq_mem_ports:
        cq_mem_ports = """,
    output reg  [63:0]           cq_mem_addr,
    input  wire [255:0]          cq_mem_rdata
"""
        cq_mem_fetch_issue = """        cq_mem_addr <= {cq_base_hi, cq_base_lo} + cq_head;"""
        cq_mem_fetch_decode = """        last_opcode <= cq_mem_rdata[7:0];
        last_tag <= cq_mem_rdata[63:32];
        last_src <= cq_mem_rdata[127:64];
        last_dst <= cq_mem_rdata[191:128];
        last_size <= cq_mem_rdata[223:192];
        if (cq_mem_rdata[7:0] == 8'h01) begin
          dma_req_valid <= 1'b1;
          dma_req_src <= cq_mem_rdata[127:64];
          dma_req_dst <= cq_mem_rdata[191:128];
          dma_req_bytes <= cq_mem_rdata[223:192];
          dma_src <= cq_mem_rdata[127:64];
          dma_dst <= cq_mem_rdata[191:128];
          dma_size <= cq_mem_rdata[223:192];
          dma_beats <= (cq_mem_rdata[223:197] + (|cq_mem_rdata[196:192]));
          dma_arlen <= (cq_mem_rdata[223:197] + (|cq_mem_rdata[196:192])) - 1;
          dma_pending <= 1'b1;
        end"""
    else:
        cq_mem_ports = ""
        cq_mem_fetch_issue = ""
        cq_mem_fetch_decode = ""

    if enable_axi_ports:
        axi_ports = """,
    output reg                   m_axi_awvalid,
    input  wire                  m_axi_awready,
    output reg  [63:0]           m_axi_awaddr,
    output reg  [7:0]            m_axi_awlen,
    output reg  [2:0]            m_axi_awsize,
    output reg                   m_axi_wvalid,
    input  wire                  m_axi_wready,
    output reg  [255:0]          m_axi_wdata,
    output reg  [31:0]           m_axi_wstrb,
    output reg                   m_axi_wlast,
    input  wire                  m_axi_bvalid,
    output reg                   m_axi_bready,
    output reg                   m_axi_arvalid,
    input  wire                  m_axi_arready,
    output reg  [63:0]           m_axi_araddr,
    output reg  [7:0]            m_axi_arlen,
    output reg  [2:0]            m_axi_arsize,
    input  wire                  m_axi_rvalid,
    output reg                   m_axi_rready,
    input  wire [255:0]          m_axi_rdata,
    input  wire                  m_axi_rlast
"""
        axi_defaults = """      m_axi_awvalid <= 1'b0;
      m_axi_awaddr <= 0;
      m_axi_awlen <= 0;
      m_axi_awsize <= 0;
      m_axi_wvalid <= 1'b0;
      m_axi_wdata <= 0;
      m_axi_wstrb <= 0;
      m_axi_wlast <= 1'b0;
      m_axi_bready <= 1'b0;
      m_axi_arvalid <= 1'b0;
      m_axi_araddr <= 0;
      m_axi_arlen <= 0;
      m_axi_arsize <= 0;
      m_axi_rready <= 1'b0;"""
        axi_fsm = """      // AXI DMA shim: burst read then burst write.
      case (dma_state)
        0: begin
          if (dma_pending) begin
            if (dma_beats_left == 0) begin
              dma_beats_left <= dma_beats;
              dma_rd_idx <= 0;
              dma_wr_idx <= 0;
            end
            m_axi_arvalid <= 1'b1;
            m_axi_araddr <= dma_src;
            m_axi_arlen <= dma_arlen;
            m_axi_arsize <= 3'd5; // 32B beat
            if (m_axi_arready) begin
              dma_state <= 1;
            end
          end
        end
        1: begin
          m_axi_rready <= 1'b1;
          if (m_axi_rvalid) begin
            dma_buf_mem[dma_rd_idx] <= m_axi_rdata;
            dma_rd_idx <= dma_rd_idx + 1;
            if (m_axi_rlast) begin
              dma_state <= 2;
            end
          end
        end
        2: begin
          m_axi_awvalid <= 1'b1;
          m_axi_awaddr <= dma_dst;
          m_axi_awlen <= dma_arlen;
          m_axi_awsize <= 3'd5;
          if (m_axi_awready) begin
            dma_state <= 3;
          end
        end
        3: begin
          m_axi_wvalid <= 1'b1;
          m_axi_wdata <= dma_buf_mem[dma_wr_idx];
          m_axi_wstrb <= 32'hFFFF_FFFF;
          m_axi_wlast <= (dma_beats_left == 1);
          if (m_axi_wready) begin
            if (dma_beats_left == 1) begin
              dma_state <= 4;
            end else begin
              dma_wr_idx <= dma_wr_idx + 1;
              dma_beats_left <= dma_beats_left - 1;
            end
          end
        end
        4: begin
          m_axi_bready <= 1'b1;
          if (m_axi_bvalid) begin
            dma_beats_left <= 0;
            dma_state <= 0;
            dma_pending <= 1'b0;
            irq_status[IRQ_EVENT] <= 1'b1;
          end
        end
        default: dma_state <= 0;
      endcase"""
        axi_reset = """      m_axi_awvalid <= 1'b0;
      m_axi_awaddr <= 0;
      m_axi_awlen <= 0;
      m_axi_awsize <= 0;
      m_axi_wvalid <= 1'b0;
      m_axi_wdata <= 0;
      m_axi_wstrb <= 0;
      m_axi_wlast <= 1'b0;
      m_axi_bready <= 1'b0;
      m_axi_arvalid <= 1'b0;
      m_axi_araddr <= 0;
      m_axi_arlen <= 0;
      m_axi_arsize <= 0;
      m_axi_rready <= 1'b0;"""
    else:
        axi_ports = ""
        axi_defaults = ""
        axi_fsm = ""
        axi_reset = ""

    verilog = TOP_TEMPLATE.format(
        top_name=top_name,
        mmio_addr_width_minus1=mmio_addr_width - 1,
        data_width_minus1=data_width - 1,
        dma_ports=dma_ports,
        dma_reset=dma_reset,
        dma_handshake=dma_handshake,
        dma_kick=dma_kick,
        cq_mem_ports=cq_mem_ports,
        cq_mem_fetch_issue=cq_mem_fetch_issue,
        cq_mem_fetch_decode=cq_mem_fetch_decode,
        axi_ports=axi_ports,
        axi_defaults=axi_defaults,
        axi_fsm=axi_fsm,
        axi_reset=axi_reset,
    )

    (out_path / "top.v").write_text(verilog, encoding="utf-8")
    (out_path / "config.json").write_text(json.dumps(cfg, indent=2) + "\n", encoding="utf-8")

    if bool(cfg.get("enable_axi_lite_wrapper", False)):
        bridge = AXI_LITE_BRIDGE.format(
            data_width_minus1=data_width - 1,
            mmio_addr_width_minus1=mmio_addr_width - 1,
        )
        wrapper = AXI_LITE_WRAPPER.format(top_name=top_name)
        (out_path / "axi_lite_mmio_bridge.sv").write_text(bridge, encoding="utf-8")
        (out_path / "top_axi.v").write_text(wrapper, encoding="utf-8")


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate stub NPU RTL.")
    parser.add_argument("--config", required=True, help="Path to config JSON")
    parser.add_argument("--out", required=True, help="Output directory")
    args = parser.parse_args()

    cfg = load_config(args.config)
    write_outputs(cfg, args.out)
    print(f"rtlgen: wrote RTL to {args.out}")
    return 0


if __name__ == "__main__":
    sys.exit(main())
